#include <stdio.h>

int main(){
	int a=2147483647;
	printf("a: %d\na: %d\n", a++, a);//overflow!
	
	unsigned int b=-1;
	printf("value of b by unsigned int: %u\n", b);//4294967295 just think it as +
	
	return 0;
} 

/*
1.	정수에서 음수를 표현하기 위해 첫 비트를 부호비트를 사용하면, +0과 -0의 구분으로 인하여 컴퓨터 자원이 낭비된다. 
	고로 2의 보수(2's complement)표현법을 사용하는데, 2의 보수 표현 체계 하에서 어떤 수의 부호를 바꾸려면 비트를 반전시킨 뒤 1을 더하면 된다.
	ex. 0111(7)->1000(반전)->1001(+1)  
2.	int에 최대값에서 INC를 하게 되면, CPU는 그냥 1을 증가시켜버리는데 0x7FFFFFFF에서 0x80000000이 된다.
	이를 2의 보수로 해석하여 반전하고 1을 더하면 -0x80000000, 즉 음수 값이 된다.
	 이처럼 자료형의 최대 범위보다 큰 수를 대입하여 발생되는 문제를 오버플로우(overflow)라고 하며, C차원에서 오버플로우의 발생여부를 알 수 없기에 자료형의 크기를 신경써주자. 
*/
