#include <iostream>
#include <algorithm>
#include <vector> 
#include <functional>
#include <string>

/*1
//for print Vector!
template <typename Iter>//get Iter type as template argument
void print(Iter begin, Iter end){//get Iterator's begin and end as argument
	while(begin!=end){//if content exist
		std::cout<<*begin<<" ";//print that's value by *operator
		begin++;//and pass to next content
	}
	std::cout<<std::endl;
}
//compare functor 1
struct int_compare{//Functor for comparing.
	bool operator()(const int& a, const int& b) const{
		return a>b;
	}
};//but already many common types get operator< or >! so make it by template with expanding.
//compare functor 2
template <typename T>
struct greater_comp{//make new version of compare funtor! BUT it's already in functionla header!!! that's 'greater<int>()'!
	bool operator()(const T& a, const T& b) const{
		return a>b;
	}
};
//compare functor 3 is in std::greater<>()!!

//for stable_sort
struct User{//for show difference of stable_sort and common sort
	std::string name;
	int age;
	
	User(std::string name, int age):name(name), age(age){}
	bool operator<(const User& u) const {//comparing is only depending on User.age regardless of name.
		return age<u.age;
	}
};
std::ostream& operator<<(std::ostream& o, const User& u){
	o<<u.name<<" , "<<u.age;
	return o;
}

int main(){
	//<1. normal sort>
	std::vector<int> vec;
	vec.push_back(5);
	vec.push_back(3);
	vec.push_back(1);
	vec.push_back(6);
	vec.push_back(4);
	vec.push_back(7);
	vec.push_back(2);
	
	std::cout<<"before sort ----"<<std::endl;
	print(vec.begin(), vec.end());//push functor! for comparing.
	std::sort(vec.begin(), vec.end(), std::greater<int>());//get Iterator. This iterator has to satisfy RandomAccessIterator type, so deque and vector only can use sort_function.
	//ex_list is BidirectionalIterator. so sort(l.begin(), l.end()); makes error.
	std::cout<<"after sort ----"<<std::endl;
	print(vec.begin(), vec.end());
	
	std::cout<<std::endl;
	//<2. partial_sort>
	std::vector<int> vec_;
	vec_.push_back(5);
	vec_.push_back(3);
	vec_.push_back(1);
	vec_.push_back(6);
	vec_.push_back(4);
	vec_.push_back(7);
	vec_.push_back(2);
	
	std::cout<<"before sort ----"<<std::endl;
	print(vec_.begin(), vec_.end());
	std::partial_sort(vec_.begin(), vec_.begin()+3, vec_.end());//sort [start, middle) in all elements at [start, end)
	//partial_sort's complexity is O(NlogM) (all size is N, part's size is M)
	std::cout<<"after sort ----"<<std::endl;
	print(vec_.begin(), vec_.end());//left element locate randomly!
	//when we don't need sort all elements, it will be used. like we want to know only highest 10%'s grade.
	
	std::cout<<std::endl;
	//<3. stable_sort>
	std::vector<User> vec3;
	for(int i=0; i<100; i++){//make test data
		std::string name="";
		name.push_back('a'+i/26);
		name.push_back('a'+i%26);//name is like "aa, ab, ac..." already sorted data
		vec3.push_back(User(name, static_cast<int>(rand()%10)));//age is random value.
	}
	
	std::vector<User> vec4=vec3;
	
	std::cout<<"before sort ----"<<std::endl;
	print(vec3.begin(), vec3.end());
	
	std::sort(vec3.begin(), vec3.end());
	std::cout<<"after sort ----"<<std::endl;
	print(vec3.begin(), vec3.end());
	
	std::cout<<"stable_sort case ---"<<std::endl;
	std::stable_sort(vec4.begin(), vec4.end());
	print(vec4.begin(), vec4.end());
	
	return 0;
}*/

/*2
template<typename Iter>
void print(Iter begin, Iter end){
	while(begin!=end){
		std::cout<<"["<<*begin<<"] ";
		begin++;
	}
	std::cout<<std::endl;
}

//for remove_if function's description
struct is_odd{//functor for pass eleminate condition.
	bool operator()(const int& i){
		return i%2==1;
	}
};
//for show pass real function not functor
bool odd(const int& i){
	return i%2==1;
}

//for add condition of remove_if
struct Is_odd{
	int* num_delete;
	
	Is_odd(int* num_delete):num_delete(num_delete){}//constructor with initialize list
	bool operator()(const int& i){
		if(*num_delete>=2)//already delete two elements
			return false;
		if(i%2==1){//erase element
			(*num_delete)++;
			return true;
		}
		return false;
	}
	
};

int main(){
	//<1. remove function>
	std::vector<int> vec;
	vec.push_back(5);
	vec.push_back(3);
	vec.push_back(1);
	vec.push_back(2);
	vec.push_back(3);
	vec.push_back(4);
	
	std::cout<<"initial vec's status ------"<<std::endl;
	print(vec.begin(), vec.end());
	
	std::cout<<"eleminate element that's value is 3 in vector ---"<<std::endl;
	vec.erase(std::remove(vec.begin(), vec.end(), 3), vec.end());//erase function has two model that is 'Iterator erase(Iterator pos)', and 'Iterator erase(Iterator first, Iterator last)'
	//first model is just erase element that's in pos, second model is erase all elements in first~last.
	//In content, remove do shift work that finds element 3. than vector that doesn't has 3. but It's not actually delete. just shift.
	//So, by using erase function, we can actually delete value 3. 3 remains in last space. so erase that space to vec.end()
	print(vec.begin(), vec.end());
	//p.s remove function's iterator type is ForwardIterator. so we can use it not only vector, but also list, set, map...etc!
	
	std::cout<<std::endl;
	//<2. remove_if function>
	std::vector<int> vec2;
	vec2.push_back(5);
	vec2.push_back(3);
	vec2.push_back(1);
	vec2.push_back(2);
	vec2.push_back(3);
	vec2.push_back(4);
	
	std::cout<<"initial vec's status ------"<<std::endl;
	print(vec2.begin(), vec2.end());
	
	std::cout<<"eleminate odd element in vector ---"<<std::endl;
	vec2.erase(std::remove_if(vec2.begin(), vec2.end(), is_odd()), vec2.end());//pass functor as delete condition.
	//of coursely, we can pass ral function like it
	vec2.erase(std::remove_if(vec2.begin(), vec2.end(), odd),  vec2.end());
	print(vec2.begin(), vec2.end());
	
	std::cout<<std::endl;
	//<3. add condition to remove_if>
	std::vector<int> vec3;
	vec3.push_back(5);
	vec3.push_back(3);
	vec3.push_back(1);
	vec3.push_back(2);
	vec3.push_back(3);
	vec3.push_back(4);
	
	std::cout<<"initial vec's status ------"<<std::endl;
	print(vec3.begin(), vec3.end());
	
	std::cout<<"eleminate 2 element in front of odd element in vector ---"<<std::endl;
	int num_delete=0;//for prevent (logical...?) error
	vec3.erase(std::remove_if(vec3.begin(), vec3.end(), Is_odd(&num_delete)), vec3.end());
	
	//vec3.erase(std::remove_if(vec3.begin(), vec3.end(), bool is_odd(int i){return i%2==1;}), vec3.end());
	//very good way! but it doesn't allow in C++ ¤» TT but it's solution is made in C++ 11!
	
	print(vec3.begin(), vec3.end());//error! 3 odd elements are deleted! not 2!
	//In standard of C++, functor in remove_if will not change inner status. it means, using num_delete is impossible in principle.
	//because in remove_if, functor can be copied any times by code.
	
	return 0;
}*/

/*3
class SomeClass{
	std::vector<int> vec;
	int num_erased;
	
	public:
		SomeClass(){
			vec.push_back(5);
			vec.push_back(3);
			vec.push_back(1);
			vec.push_back(2);
			vec.push_back(3);
			vec.push_back(4);
			
			num_erased=1;
			
			vec.erase(std::remove_if(vec.begin(), vec.end(),
				[this](int i){//use this pointer not &num_erased! it's impossible because member variable doesn't has address before instantiation.
					if(this->num_erased>=2)
						return false;
					else if(i%2==1){
						this->num_erased++;
						return true;
					}
					return false;
				}),
				vec.end()
			);
		}
		
}; 

template <typename Iter>
void print(Iter begin, Iter end){
	while(begin!=end){
		std::cout<<"["<<*begin<<"] ";
		begin++;
	}
	std::cout<<std::endl;
}

int main(){
	std::vector<int> vec;
	vec.push_back(5);
	vec.push_back(3);
	vec.push_back(1);
	vec.push_back(2);
	vec.push_back(3);
	vec.push_back(4);
	
	std::cout<<"initial vec's status"<<std::endl;
	print(vec.begin(), vec.end());
	
	std::cout<<"eleminate odd element in vector ---"<<std::endl;
	int num_erased=0;
	vec.erase(std::remove_if( vec.begin(), vec.end(), [&num_erased](int i)->bool{//By capture list, we can use num_erased like in scope. It means we can change value of num_erased in function.
		//if we don't use & use just num_erased, it will be const. so we can't change that value, only read.
		if(num_erased>=2)
			return false;
		else if(i%2==1){
			num_erased++;
			return true;
		}
		return false;
	} ), vec.end());
	
	print(vec.begin(), vec.end());
	
	return 0;
}*/

//4
template<typename Iter>
void print(Iter begin, Iter end){
	while(begin!=end){
		std::cout<<"["<<*begin<<"] ";
		begin++;
	}
	std::cout<<std::endl;
} 
/*4
int main(){
	std::vector<int> vec;
	vec.push_back(5);
	vec.push_back(3);
	vec.push_back(1);
	vec.push_back(2);
	vec.push_back(3);
	vec.push_back(4);
	
	std::vector<int> vec2(6, 0);//initialize vec2 to '0' 6 times. 
	
	std::cout<<"initial vec's & vec2's status -----"<<std::endl;
	print(vec.begin(), vec.end());
	print(vec2.begin(), vec2.end());
	
	std::cout<<"add 1 to all element of vec and save to vec2"<<std::endl;
	std::transform(vec.begin(), vec.end(), vec2.begin(), [](int i) {return i+1;});//not need for loop! and high read ability!
	print(vec.begin(), vec.end());
	print(vec2.begin(), vec2.end());
	
	return 0;
}*/

/*5-1
int main(){
	std::vector<int> vec;
	vec.push_back(5);
	vec.push_back(3);
	vec.push_back(1);
	vec.push_back(2);
	vec.push_back(3);
	vec.push_back(4);
	
	auto result=std::find(vec.begin(), vec.end(), 3);
	std::cout<<"3 is "<<std::distance(vec.begin(), result)+1<<"st element"<<std::endl;
	
	//if you want to find all e element
	auto current=vec.begin();
	while(true){
		current=std::find(current, vec.end(), 3);
		if(current==vec.end())
			break;
		std::cout<<"3 is "<<std::distance(vec.begin(), current)+1<<"st element"<<std::endl;
		current++;
	}
	
	//find_if function
	auto current2=vec.begin();
	while(true){
		current2=std::find_if(current2, vec.end(), [](int i)->int{return i%3==2;});//find_if function get functor as argument
		if (current2==vec.end())
			break;
		std::cout<<"element that satisfies i%3==2 is : "<<*current2<<std::endl;
		current2++;
	} 
	
	return 0;
}*/

//5-2
struct User{
	std::string name;
	int level;
	
	User(std::string name, int level) : name(name), level(level) {}
	bool operator==(const User& user) const{
		if(name==user.name && level==user.level)
			return true;
		return false;
	}
};

class Party{
	std::vector<User> users;
	
	public:
		bool add_user(std::string name, int level){
			User new_user(name, level);
			if(std::find(users.begin(), users.end(), new_user) != users.end())
				return false;//overlap
			users.push_back(new_user);
			return true;
		}
		bool can_join_dungeon(){//all >15 level
			return std::all_of(users.begin(), users.end(), [](User& user) {return user.level>=15;});
		}
		bool can_use_special_item(){//anyone >19 level
			return std::any_of(users.begin(), users.end(), [](User& user){return user.level>=19;});
		}
};
int main(){
	Party party;
	party.add_user("covid",19);
	party.add_user("column",0);
	party.add_user("row",1);
	party.add_user("cookie", 10);
	party.add_user("covid", 19);
	
	std::cout<<std::boolalpha;
	std::cout<<"can join dungeon? "<<party.can_join_dungeon()<<std::endl;
	std::cout<<"can use special item? "<<party.can_use_special_item()<<std::endl;
	
	return 0;
}


/*
[0.	µé¾î°¡±â¿¡ ¾Õ¼­]
1.	ÄÁµ¥ÀÌ³Ê¿¡ ¹Ýº¹ÀÚ¸¦ °¡Áö·Î ½±°Ô »ç¿ëÇÏ°Ô µµ¿ÍÁÖ´Â °ÍÀÌ ¾Ë°í¸®Áò ¶óÀÌºê·¯¸®ÀÎµ¥, ¿©±â¿¡ Á¤ÀÇµÇ¾î ÀÖ´Â ¿©·¯ ÇÔ¼öµé·Î ÀÛ¾÷À» ¼öÇàÇÑ´Ù.
	template <typename Iter>
	void do_something(Iter begin, Iter end);//get iterator's start and end
	È¤Àº
	template <typename Iter, typename Pred>
	void do_something(Iter begin, Iter end, Prd pred)//get iterator's start and end with 'special condition' that's called Predicate
	²ÃÀ» µû¸¥´Ù. 
	ÀÌ¶§ Æ¯Á¤ÇÑ Á¶°ÇÀ» ¼­¼úÀÚ(Predicate)¶ó°í ºÎ¸£¸ç pred¿¡´Â º¸Åë boolÀ» returnÇÏ´Â Functor(ÇÔ¼ö °´Ã¼)¸¦ Àü´ÞÇÏ°Ô µÈ´Ù.

[1.	Á¤·Ä(sort, stable_sort, partial_sort)]_³ë¸»Á¤·Ä, Á¤·Ä½Ã °ª °°À¸¸é ¼ø¼­º¸Á¸, ÀÏºÎºÐ¸¸ Á¤·Ä 
1.	std::sort(vec.begin(), vec.end())´Â RandomAccessIterator°¡ Áö¿øµÇ´Â deque¿Í vector¸¸ °¡´ÉÇÏ´Ù.
	¶ÇÇÑ ¸¸¾à ³»¸²Â÷¼øÀ¸·Î Á¤·ÄÇÏ°í ½Í´Ù¸é, compareÀ» ¾î¶»°Ô ÇÒ °ÍÀÎÁö¸¦ ÀÎÀÚ·Î ³Ñ°ÜÁÖ¸é µÈ´Ù. 
2.	stable_sort´Â sort´Â Á¤·Ä °úÁ¤¿¡¼­ ¿ø¼Òµé°£ÀÇ »ó´ëÀû À§Ä¡¸¦ ¹Ù²Ù´Â°Í°ú´Â ´Þ¸® Ã³À½ »óÅÂ ±×´ë·Î À¯ÁöÇÑ´Ù.
	°í·Î Á¶±Ý ´õ ½Ã°£ÀÌ °É¸®´Âµ¥, C++Ç¥ÁØ¿¡ µû¸£¸é, ÃÖ¾ÇÀÇ °æ¿ì sort´Â O(nlogn)ÀÎ ¹Ý¸é, stable_sort´Â O(n(log n)^2)ÀÌ´Ù.
	
[2.	¿ø¼Ò Á¦°Å(remove, remove_if)]
1.	´ëºÎºÐÀÇ ÄÁÅ×ÀÌ³Ê¿¡¼­ ¿ø¼Ò¸¦ Á¦°ÅÇÏ´Â ÇÔ¼ö¸¦ Áö¿øÇÏ°í ÀÖÁö¸¸, ¿ø¼Ò°¡ Á¦°ÅµÉ ¶§ ¸¶´Ù ±âÁ¸¿¡ Á¦°ÅÇÏ¿´´ø ¹Ýº¹ÀÚµéÀÌ ÃÊ±âÈ­µÇ±â¿¡ ÇØ´ç À§Ä¡¸¦ °¡¸®Å°´Â ¹Ýº¹ÀÚ¸¦ °è¼Ó ´Ù½Ã °¡Á®¿Í¾ß Çß´Ù.
	std::vector<int>::iterator itr=vec.begin();
	for(; itr!=vec.end(); ++itr){
		if(*itr==3){
			vec.erase(itr);
			itr=vec.begin();
		}
	}
2.	remove_if ÇÔ¼ö´Â ÇÔ¼ö °´Ã¼°¡ ÀÎÀÚ¸¦ µü 1°³¹Þ´Â´Ù°í °¡Á¤Çß´Âµ¥, ÀÌ·³ È£ÃâµÇ´Â operator()À» ÅëÇØ¼­´Â ¿ø¼Ò¿¡ ´ëÇÑ Á¤º¸ ¸»°í´Â Ãß°¡ÀûÀÎ Á¤º¸¸£ Àü´ÞÇÏ±â ¾î·Æ´Ù. 
	°í·Î È¦¼öÀÎ ¿ø¼ÒµéÀ» »èÁ¦ÇÏµÇ Ã³À½ 2°³¸¸ »èÁ¦ÇÏ´Â ¿¹Á¦¸¦ ¸¸µé¾îº¸ÀÚ. 
	 ÇÔ¼ö°´Ã¼ÀÇ °æ¿ì ¸» ±×´ë·Î °´Ã¼ÀÌ±â¿¡ ¸â¹öº¯¼ö¸¦ »ý°¢ÇÒ ¼ö ÀÖ´Ù! 
3.	remove_if¸¦ ½ÇÁ¦·Î ±¸ÇöÇßÀ» ¶§, ÇÔ¼ö °´Ã¼°¡ ¿©·¯¹ø º¹»çµÉ ¼ö ÀÖ±â ¶§¹®¿¡ remove_if¿¡ Àü´ÞµÇ´Â ÇÔ¼ö °´Ã¼ÀÇ °æ¿ì ÀÌÀüÀÇ È£Ãâ¿¡ ÀÇÇØ ³»ºÎ »óÅÂ°¡ ´Þ¶óÁö¸é ¾ÈµÈ´Ù. Áï, ÇÔ¼ö °´Ã¼ ¾È¿¡ ÀÎ½ºÅÏ½º º¯¼ö¸¦ ³Ö´Â°ÍÀº ¿øÄ¢»ó ¾ÈµÇ´Â °ÍÀÌ´Ù.
	¹°·Ð, ÀÌ´Â remove_if¸¦ ¾î¶»°Ô ±¸ÇöÇÏ³Ä¿¡ µû¶ó¼­ ´Þ¶óÁö´Âµ¥,  
template <class ForwardIterator, class UnaryPredicate>
ForwardIterator remove_if(ForwardIterator first, ForwardIterator last,
                          UnaryPredicate pred) {
  ForwardIterator result = first;
  while (first != last) {
    if (!pred(*first)) {  // <-- ÇÔ¼ö °´Ã¼ pred ¸¦ ½ÇÇàÇÏ´Â ºÎºÐ
      *result = std::move(*first);
      ++result;
    }
    ++first;
  }
  return result;
}
	ÀÇ °æ¿ì pred°¡ º¹»çµÇÁö ¾Ê°í È£ÃâµÇ¾î Á¤È®È÷ °á°ú°¡ ³ª¿Â´Ù. ´Ù¸¸ C++Ç¥ÁØÀº remove_if¸¦ ¾î¶»°Ô ±¸ÇöÇÏ¶ó°í ¾ÈÁ¤ÇØ¼­ ¾Æ·¡¿Í °°ÀÌ ±¸ÇöµÇ¾ú´Ù.
template <class ForwardIt, class UnaryPredicate>
ForwardIt remove_if(ForwardIt first, ForwardIt last, UnaryPredicate pred) {
  first = std::find_if(first, last, pred);  // <- pred ÇÑ ¹ø º¹»çµÊ
  if (first != last)
    // ¾Æ·¡ for ¹®Àº first + 1 ºÎÅÍ ½ÃÀÛÇÑ´Ù°í ºÁµµ µÈ´Ù (++i != last)
    for (ForwardIt i = first; ++i != last;)
      if (!pred(*i))  // <-- pred È£Ãâ ÇÏ´Â ºÎºÐ
        *first++ = std::move(*i);
  return first;
}
	ÀÌ fund_if°¡ predÀÇ ·¹ÆÛ·±½º¸¦ ¹Þ´Â °ÍÀÌ ¾Æ´Ï¶ó º¹»ç»ý¼º ¹öÀüÀ» ¹Þ±â¿¡ for¹®¿¡¼­ ¿ø¼Ò¸¦ Áö¿ü´Ù´Â Á¤º¸°¡ ¼Ò¸êµÇ¾î num_delete°¡ ´Ù½Ã 0ºÎÅÍ ½ÃÀÛÇÏ°Ô µÈ´Ù.
4.	°í·Î, num_delete¸¦ °´Ã¼ ³»ºÎ º¯¼ö°¡ ¾Æ´Ñ ¿ÜºÎ º¯¼ö·Î »©¾ß ÀÌ ¹®Á¦¸¦ ÇØ°áÇÒ ¼ö ÀÖ´Ù.
	ÇÑ°¡Áö ¾ÈÁÁÀº Á¡Àº STLÀ» »ç¿ëÇÒ ¶§ ¸¶´Ù ¿ÜºÎ¿¡ Å¬·¡½º³ª ÇÔ¼ö¸¦ ÇÏ³ª¾¿ ¸¸µé¾îÁà¾ß ÇÑ´Ù´Â °ÍÀÌ´Ù. °í·Î ³ªÁß¿¡ ÄÚµå°¡Ä¿Á³À» ¶§, °¡µ¶¼ºÀÌ ¶³¾îÁú ¼ö ÀÖ¾î
	STL¾Ë°í¸®Áò ±× ¾È¿¡ Á÷Á¢ ½á³õ´Â °ÍÀÌ ÀÌ»óÀûÀÎ ¹æ¹ýÀÌ´Ù. 

[3.	¶÷´Ù ÇÔ¼ö(lambda function)]
1.	[capture list] (¹Þ´Â ÀÎÀÚ)->¸®ÅÏ Å¸ÀÔ{ÇÔ¼ö º»Ã¼} À¸·Î Á¤ÀÇµÇ¸ç, ¸®ÅÏ Å¸ÀÔÀ» »ý·«ÇÏ¸é ¾Ë¾Æ¼­ ÄÄÆÄÀÏ·¯°¡ ÃßÃøÇØ ÁÜ. but returnÀÌ ¿©·¯°³¿© ÃßÃøÇÒ ¼ö ¾ø´Ù¸é ÄÄÆÄÀÏ¿À·ù 
	ÀÌ´Â auto func=·Î ¹Þ¾Æ¼­ func(4)Ã³·³ ÇÔ¼ö °´Ã¼¸¦ »ý¼ºÇÑ ÈÄ¿¡ È£ÃâÇÒ ¼öµµ ÀÖÀ½. Áï, ¸» ±×´ë·Î ÇÔ¼ö ÀÓ. 
	 ÇÏÁö¸¸, À§¿¡¼­ ¹ß»ýÇÑ ¹®Á¦¸¦ ´Ù½Ã »ìÆìº¸¸é, ÇÔ¼ö¸¦ ÀçÈ£ÃâÇÏ¸é ÇÔ¼ö ¾ÈÀÇ º¯¼ö°¡ ÀçÁ¤ÀÇµÇ¾î °á±¹ odd element¸¦ ¸î °³ Áö¿ü´ÂÁö ¸ð¸¥´Ù´Â Á¡ÀÌ ¿©ÀüÇÒ °Í °°Áö¸¸,
	lambdaÇÔ¼ö´Â Ä¸ÃÄ ¸ñ·Ï(capture list)¸¦ »ç¿ëÇÏ¿© ±× º¯¼ö¿¡ Á¢±ÙÇÒ ¼ö ÀÖ´Ù. 
2.	¸¸¾à Å¬·¡½º ¾È¿¡ ¸â¹ö ÇÔ¼ö ¾È¿¡¼­ ¸â¹ö º¯¼ö¸¦ ÂüÁ¶ÇÒ ¶§´Â, Á¶±Ý ´Ù¸¥°Ô À§Ã³·³ &num_erased¶ó°í ÇÏ¸é ¾ÈµÈ´Ù. ¿ì¸®´Â ½ÇÁ¦ »ý¼ºµÈ °´Ã¼ ¾ÈÀÇ ¸â¹ö¸¦ ÂüÁ¶ÇØ¾ßÇÏ±â¿¡
	ÀÌ·¯ÇÑ °æ¿ì¿£ this·Î classÀÚÃ¼¸¦ ³ªÅ¸³»¾î »ç¿ëÇÑ´Ù. 
3.	Ä¸ÃÄ¸®½ºÆ®ÀÇ »ç¿ë¹ýÀº ¸î°³¸¸ °£´ÜÈ÷ Á¤¸®ÇÏ¸é
	-[] ¾Æ¹«°Íµµ Ä¸ÃÄ ¾ÈÇÔ
	-[&a, b] a´Â ·¹ÆÛ·±½º·Î Ä¸ÃÄ, b´Â º¹»çº»À¸·Î Ä¸ÃÄ(º¯°æ ºÒ°¡´É)
	-[&] ¿ÜºÎÀÇ ¸ðµç º¯¼öµéÀ» ·¹ÆÛ·±½º·Î Ä¸ÃÄ
	-[=] ¿ÜºÎÀÇ ¸ðµç º¯¼öµéÀ» º¹»çº»À¸·Î Ä¸ÃÄ 
	
[4.	¿ø¼Ò ¼öÁ¤ÇÏ±â(transform)]
1.	transform ÇÔ¼ö¸¦ »ç¿ëÇÏ¿© ¿ø¼ÒµéÀ» ¼öÁ¤. 
2.	transform(½ÃÀÛ ¹Ýº¹ÀÚ, ³¡ ¹Ýº¹ÀÚ, °á°ú¸¦ ÀúÀåÇÒ ÄÁÅ×ÀÌ³ÊÀÇ ½ÃÀÛ ¹Ýº¹ÀÚ, Pred) 
	
[5.	¿ø¼Ò¸¦ Å½»öÇÏ´Â ÇÔ¼ö(find, 'find_if, any_of, all_od' µîµî)]
1.	template <class InputIt, class T>
	InputIt find(InputIt first, InputIt last, const T& value)
	first~lastÁß value¿Í °°Àº°Ô ÀÖ´ÂÁö È®ÀÎÇÏ°í ÀÖÀ¸¸é ¹Ýº¹ÀÚ ¸®ÅÏ. Áßº¹µÇ¸é °¡Àå ÃÖ±Ù²¨. 
2.	find °è¿­ ÇÔ¼öµéÀ» »ç¿ëÇÒ ¶§ ÁÖÀÇÇÒ Á¡Àº, ¸¸¾à ±âº»ÀûÀ¸·Î .findÇÔ¼ö°¡ Áö¿øµÈ´Ù¸é ÀÌ¸¦ »ç¿ëÇØ¾ß ´õ ºü¸£´Ù. ¿Ö³Ä¸é ¾Ë°í¸®ÁòÀÇ find´Â ÄÁÅ×ÀÌ³ÊÀÇ ±¸Á¶¸¦ °í·ÁÇÏÁö ¾Ê´Â find±â ¶§¹®ÀÌ´Ù.
	ex) setÀÇ find´Â Á¤·ÄµÇ¾îÀÖ±â¿¡ O(logn), unordered_setÀÇ find´Â ÇØ½ÃÅ×ÀÌºíÀ» ÀÌ¿ëÇÏ±â¿¡ O(1). ¸¸¾à ¾Ë°í¸®ÁòÀÇ find´Â ÇÏ³ª¾¿ È®ÀÎÇÏ¹Ç·Î O(n).
	 Áï, ¾Ë°í¸®ÁòÀÇ find´Â vectorÃ³·³ find¸¦ Áö¿øÇÏÁö ¾Ê´Â ÄÁÅ×ÀÌ³Ê¿¡ »ç¿ëÇÏÀÚ! 
3.	any_of´Â ÀÎÀÚ·Î ¹ÞÀº ¹üÀ§¿¡¼­ ÇÏ³ª¶óµµ ÃæÁ·ÇÏ¸é true¸®ÅÏ, all_of´Â ¸ðµÎ°¡ ÃæÁ·ÇÏ¸é true¸¦ ¸®ÅÏÇÑ´Ù. and¿Í or°ú ºñ½ÁÇÑ ´À³¦ÀÌ´Ù.
 
*/
