/*1. 기본적인 참조자의 정의 알아보기 
#include <iostream>

int main() {
  int a = 3;
  int& another_a = a;//정의 시에 누구의 별명인지를 명시 해야 함.+다른 변수를 참조할 수 없음
  //메모리 상에서 존재하지 않음. 말 그대로 참조자. 늑대인간,,?
  another_a = 5;
  std::cout << "a : " << a << std::endl;
  std::cout << "another_a : " << another_a << std::endl;

  return 0;
}
*/

/*2. 함수에서의 참조자 사용 알아보기. 
#include <iostream>

int change_val(int& p) {//사실상 int& p=number을 바로 정의하는 것이기에 가능. 
	p = 3;

	return 0;
}
int main() {
	int number = 5;

	std::cout << number << std::endl;
	change_val(number);//별명만 바꾼다고 생각. 
	std::cout << number << std::endl;
}
*/

/*3. 참조자를 잘 이해했는지 확인하기. 
// 참조자 이해하기

#include <iostream>

int main() {
  int x;
  int& y = x;
  int& z = y;//int&& X 별명의 별명을 만들 필요는 없다. 

  x = 1;
  std::cout << "x : " << x << " y : " << y << " z : " << z << std::endl;

  y = 2;
  std::cout << "x : " << x << " y : " << y << " z : " << z << std::endl;

  z = 3;
  std::cout << "x : " << x << " y : " << y << " z : " << z << std::endl;
}//다 같은 결괏갑. x의 별명만 붙여준 것이기 때문에. 
*/

/*4. 상수에 대한 참조자의 가능여부 확인하기. 
#include <iostream>

int main() {
  int &ref = 4;
	//조금만 생각을 해봐도 4의 위치를 참조자로 가져올 수 있다면, 4를 가리키는 참조자의 값을 5로 바꿔버린다는 논리가 가능해짐. 
  std::cout << ref << std::endl;//error occur: error C2440: 'initializing' : cannot convert from 'int' to 'int &' 
}
//const int &ref=4;처럼 상수 참조자를 선언한다면 리터럴도 참조할 수 있다. (리터럴: 소스 코드 상에서 고정된 값을 가지는 것 ex. 문자열 리터럴) 
//위의 코드가 의미하는 바는 값을 변경하지 않겠다!라는 의미. 즉, 변경하지 않고 참조만 하겠다. 
//포인터는 잘못 사용할 확률이 높은데다 참조자는 포인터보다 쉽기 때문에 자주 사용. 
*/

/*5. 레퍼런스의 배열에 대하여 생각해보기. 
//앞서서 레퍼런스는 반드시 정의와 함께 초기화를 해야 한다!!
int& arr[2] = {a, b}; 이런식으로 저의를 해버리면 될 것 같지만 error occur_ error C2234: 'arr' : arrays of references are illegal
언어적 차원에서 불법이라 해버림
->array는 주솟값으로 변환이 될 수 있어야 함. int array[2]={1,2};에서 array[0]을 *array로, array[1]을 *(array+1)로
//처리할 수 있게 정의 자체가 되어 있음. 그럼 위의 경우, array를 사용하려면 메모리 주소에 접근이 가능해야 하는데
//참조자의 경우 메모리 주소로 할당이 되지 않기 때문에 어레이로 참조자를 정의하는 것이 불가능함. 
*/

/*6. 배열들의 레퍼런스 생각해보기. 
#include <iostream>

int main() {
  int arr[3] = {1, 2, 3};
  int(&ref)[3] = arr;//배열의 레퍼런스의 경우, 포인터와는 달리 반드시 배열의 크기를 명시해줘야함. 

  ref[0] = 2;
  ref[1] = 3;
  ref[2] = 1;

  std::cout << arr[0] << arr[1] << arr[2] << std::endl;
  return 0;
}
int arr[3][2] = {1, 2, 3, 4, 5, 6};
int (&ref)[3][2] = arr;//이런식으로도 가능. 
*/

/*7. 함수의 레퍼런스 리턴에 대하여 생각해보기. 
[지역변수의 레퍼런스를 리턴?]
#include <iostream> 

int& function() { 
  int a = 2;
  return a;//리턴 타입이 int&라서 참조자르 리턴하게 됨. 문제는 리턴과 함께 a가 사라짐. 
}

int main() {
  int b = function();
  b = 3;
  std::cout<<b;
  return 0;//런타임 오류 발생 
}
위의 상황은 int& ref=a; 근데 a가 사라짐 int b=ref;라는 의미임. 즉 본체는 사라졌는데 별명만 남음.
 이렇게 원래 참조하던 것이 사라진 레퍼런스를 댕글링 레퍼런스(Dangling reference)라고 부음. _약하게 결합되서 달랑달랑거리는 상태..
그러면 이 경우는?
[외부 변수의 레퍼런스를 리턴?]
int& function(int& a) {//b를 int& a참조자로 받음 
  a = 5;//값 변경 후 리턴 
  return a;//인데 리턴 타입이 참조자. 
}

int main() {
  int b = 2;
  int c = function(b);//그걸 c라 함. 즉 문제 없이 돌아감. 
  return 0;
} 
참조자의 리턴의 장점->C언어에서 엄청 큰 구조체가 있을 때, 그냥 리턴해버리면 전체복사때문에 오래걸리지만,
구조체를 가리키는 포인터를 리턴한다면, 주소 복사 한번으로 빠르게 처리됨.
즉 레퍼런스를 리턴하면 레퍼런스가 참조하는 타입의 크기와 상관없이 주소값복사로 전달이 끝남. 
[참조자가 아닌 값을 리턴하는 함수를 참조자로 받기?]
int function() {
  int a = 5;
  return a;//함수가 리턴을 정상적으로 했어요. 
}

int main() {
  int& c = function();//근데 참조자로 받아버리네..? 
  return 0;//값을 받아버리는 순간 댕글링 레퍼런스가 되어버림.
  //그러하여 이 값을 c=2;로 해버리면 위에서의 예시처럼 런타임 오류 발생. 댕글링 레퍼런스니까. 
}
[예외사항존재]
#include <iostream>

int function() {
  int a = 5;
  return a;
}

int main() {
  const int& c = function();//위와 같은 코드이지만, const로 받음. 
  std::cout << "c : " << c << std::endl;
  return 0;
} 
*/

/*8. 생각해보기
레퍼런스가 메모리 상에 반드시 존재해야 하는 경우?: 댕글링 레퍼런스의 위험이 있으나, 발생하면 안될 때. 
존재할 필요가 없는 경우? : 변수의 쓰임새가 바뀌어 값을 이어받으나 이름을 바꿔줄 때. 하나의 변수를 다른 용도로 여러 군대 사용할 때.
*/ 



/* 정리
1. 참조자(reference): int& another_a=a or int &another_a=a 의 꼴로 선언과 동시에 반드시 초기화 하며, 메모리 상에서 존재하지 않는 a를 가리키는 a의 별명의 개념이다.
2. 참조자가 사용되는 이유는 비슷하게 접근할 수 있는 것이 포인터인데, 포인터는 다루기도 어려울 뿐더러 잘못 사용할 가능성이 크기 때문에 이를 방지하면서도 보다 쉽게 접근하기 위해 사용한다. (포인터와 참조자는 엄연히 다르다) 
3. 함수 내에서 매개변수로서 사용 될 때에 함수의 코드만 보면 초기화를 하지 않아, 오류가 뜰 것으로 보이겠지만, 인수가 넘겨지는 순간 인수의 값으로 초기화 되기 때문에 오류가 발생하지 않는다.
4. 참조자의 참조자를 만들 수 있다. 다만 모두 같은 처음의 변수를 공유한다. a=b b=c a=c
5. 상수를 포함한 리터럴의 참조자는 만들 수 없다. 만약 이가 가능하다면, 참조자를 통해서 리터럴를 바꿀 수 있다는 역설이 생긴다. 하지만,
   리터럴의 참조자를 const 자료형으로 만들어 버린다면, 위에 언급한 역설에 해당되지 않기 때문에 값의 읽기에 한해서 사용이 가능하다. 
6. 참조자의 배열은 불가능 하다. 배열의 성질 중 하나는 메모리 주소값으로 접근할 수 있다는 것인데, 참조자는 메모리 주소값이 존재하지 않는다._*(array+4)
7. 배열의 참조자는 가능하다. 대신 정의 및 초기화 시 배열의 크기를 명시해 주어야 한다._ int(&ref)[3] = arr;
8. 함수 내의 지역변수의 참조자를 리턴해버리면 리턴하는 순간 참조자의 본체가 사라지는데, 이처럼 참조자는 존재하지만 본체가 사라진 경우 댕글링 레퍼런스라고 부른다. 
   (p.s 댕글링 레퍼런스의 값을 변경하려고 하면 런타임 오류가 발생한다.) 
9. 함수 외의 변수의 레퍼런스를 인자로 받아 함수 내에서 수정 후 레퍼런스를 반환하는 것은 가능하다. 왜냐면 매개변수가 받을 때 외부의 본체가 전달되었고, 
   이를 반환했을 때에 외부함수에서의 본체가 여전히 존재하기 때문에(지역변수가 아니기 때문에) 가능하다. 
   이러한 방식의 쓰임은 C언어에서 함수 내에서 큰 구조체의 반환에서 사용되는데, 구조체 자체를 리턴해버리는 경우 값을 복사하기에 시간이 오래걸리지만, 이러한 방식으로 사용 된 레퍼런스를 반환해버리면 
   레퍼런스의 주소값만 복사하면 되기에 큰 구조체의 빠른 리턴이 가능해진다. 
10. 함수 내에서 반환된 일반 자료를 받을때 참조자로 받아버리면, 함수의 리턴으로 인해 반환된 값(정의된 변수가 존재하지 않는)이 참조자로 들어가는 것이기에 바로 댕글링 레퍼런스가 되어버린다.+마찬가지로 이를 변환하려 하면 런타임 에러. 
	하지만 만약 리턴으로 인하여 반환된 값(실체가 없는 값)을 const 변수로 받아버리면 변경이 아닌 읽기에 한해서 사용이 가능하다.  
*/
