#include <iostream>
#include <string>
#include <cstdlib>
#include <algorithm>
#include "utillity.cpp"

int main(){
	MyExcel::TxtTable table(5,5);
	std::ofstream out("test.txt");
	
	table.reg_cell(new Cell("Hello~", 0, 0, &table), 0, 0);
	table.reg_cell(new Cell("C++", 0, 1, &table), 0, 1);
	
	table.reg_cell(new Cell("Programming", 1, 1, &table), 1, 1);
	std::cout<<std::endl<<table;
	out<<table;
} 

/*
[0. 들어가기에 앞서서]
1.	Excel프로그램에서 사용할 자료구조는 크게 Vector와 Stack인데, 이들은 수식을 분석하기 위해, 즉 ExprCell객체의 to_numeric함수 내에서 사용될 예정이다.
2.	Vector는 수학의 벡터와는 다른느낌으로, 배열의 크기를 맘대로 조절할 수 있는 가변길이 배열이라고 보면 된다. 즉, 배열처럼 []연산자로 임의의 위치에 있는 원소에 마음대로 접근할 수 있고, 임의의 위치에 원솔르 추가하거나 뺄 수 있다. 
	또한, 벡터를 만드는 방법은 이전에 문자열 클래스를 만들 때와 거의 비슷하다. 문자열 역시 char데이터를 담는 가변 길이 배열이라고 볼 수 있기 때문이다.
3.	Stack은 벡터와는 다르게 임의의 위치에 있는 원소에 접근할 수 없고 항상 최상단에 있는 데이터만 접근할 수 있다. 그리고 새로운 데이터를 추가하면 항상 최상단에 오게 된다. 즉, 설거지용으로 쌓는 접시들의 모형이다. 
	새로운 설거지가 오면 맨 위에 오게되고(push), 설거지를 위해 접시를 뺄 땐 맨 위의 접시부터(push)빠진다.
4.	Vector를 활용하여 Stack을 만들 수 도 있지만, 약간 과하다. 보통 스택의 경우 링크드 리스트(Linked List)를 이용하여 구현을 한다.
	스택은 임의의 위치에 접근할 필요가 없고, 단순히 최상단에 뭐가 있는지, 그리고 새로운것을 추가하거나 빼는것만 하면 된다. 

[1. 벡터 클래스(Vector)]
1.	디폴트 인자는 C++규칙이기도 한데, 클래스 내부 함수 선언에서 디폴트 인자를 명시하였다면, 함수 본체에서 명시하면 안되고, 반대로 함수 본체에서 명시하였다면 클래스 내부 함수 선언에 명시하면 안된다. 즉, 둘 중 한 곳에만 표시해야 한다. 
2.	간단히 excel프로젝트안에서 사용할 목적으로 만든 것. 보통의 일반적인 Vector클래스는 중간에 원소를 추가하는 insert나 검색하는 find함수들도 세트로 다닌다. 

[2.	스택 클래스(Stack)]
1.	앞서 말한 것 처럼 링크드 리스트를 사용하기에 데이터를 보관하기 위해서 하나의 노드를 만들어서 노드들을 체인처럼 엮을 것이다. 
2.	문자열을 받는 것 외에도, 숫자 데이터를 보관하기 위해 NumStack을 기존의 Stack의 string을 int로 바꾸어 동일하게 처리 하였다. 
3.	NumStack클래스까지 만들어, utils.h 헤더파일과 그 하위 함수들이 정의된 utility.cpp파일로 나뉘어 MyExcel이라는 namespace에 담아두었다.

[3.	본격적인 'Cell'과 'Table'클래스]
1.	구현 중, 셀의 문자여 데이터에서 개행 문자가 있는 경우(한 셀이 여러줄이 될 때)는 고려하지 않았다. 즉, 모든 셀은 1줄로만 그려지게 된다. 이는ㄴ 실제로는 각 행의 최대 높이 역시 열과 마찬가지로 계산하여 그려야 한다. 
2.	
*/
