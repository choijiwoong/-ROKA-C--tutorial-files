#include <iostream>
#include <vector>
//라면 원소가 없는 벡터를 의미하겠지요. 만약에 vec.end() 가 마지막 원소를 가리킨다면 비어있는 벡터를 표현할 수 없게 됩니다.

int main(){
	std::vector<int> vec;
	vec.push_back(10);//add at back
	vec.push_back(20);
	vec.push_back(30);
	vec.push_back(40);
	
	//print all vector. size()'s return type is saved in size_type
	for(std::vector<int>::size_type i=0; i<vec.size(); i++)
		std::cout<<"vec's "<<i+1<<"th element :: "<<vec[i]<<std::endl;
	
	//int arr[4]={10, 20, 30, 40};
	//*(arr+2)==arr[2]==30;
	//*(itr+2)==vec[2]==30;
	
	std::vector<int>::iterator itr=vec.begin()+2;
	std::cout<<"3nd element :: "<<*itr<<std::endl;
		
}

/*
[0.	들어가기 앞서]
1.	이번 강좌에서 배우게 될 C++의 표준 템플릿 라이브러리 (STL)은 사용하는 것도 엄청 간단한데, 프로그래밍의 능률을 100%향상 시킬 수 있는 엄청난 도구이다.
	사실 이 STL의 도입으로 C++이 한발 더 도약한 것을 과언이 아니라 볼 수 있을 정도이다.

[1.	C++표준 템플릿 라이브러리(Standard Template library-STL)]
1.	C++ 표준 라이브러리에는 꽤나 많은 종류의 라이브러리 들이 있다. 대표적으로 입출력 라이브러리(iostream 등등), 시간 관련 라이브러리(chrono), 정규표현식 라이브러리(regex)등등 들이 있다.
	하지만 보통 C++템플릿 라이브러리(STL)을 일컫는다면 다음의 세 개의 라이브러리들을 의미한다.
	-임의 타입의 객체를 보관할 수 있는 컨테이너(container)_편지함 
	-컨테이너에 보관된 원소에 접근할 수 있는 반복자(iterator)_편지를 보고 원하는 편지함을 찾는 일 
	-반복자들을 가지로 일련의 작업을 수행하는 알고리즘(algorithm)_편지들을 편지함에 날짜 순서로 정렬하여 넣는 일
	 여기서 컨테이너는 템플릿의 특성 덕분에 int나 string뿐만이 아닌 우리가 만든 임의의 클래스여도 자유롭게 위 기능들을 모두 활용할 수 있다. 
	또한 반복자의 도입으로 M종류의 컨테이너, N종류의 알고리즘을 위해 MN개의 알고리즘 코드가 있어야했던 반면에, 최소한의 코드만을 작성할 수 있게 되었다.
	즉, 반복자를 이용하여 컨테이너를 추상화 시켜서 접근할 수 있기에, N개의 알고리즘으로 M종류의 컨테이너들을 모두 지원할 수 있게 되는 것이다.(후에 알고리즘 라이브러리에서 설명) 

[2.	C++ 'STL'컨테이너-벡터(std::vector)]
1.	C++ STL에서 컨테이너는 크게 두 가지 종류가 있는데, 배열처럼 객체들을 순차적으로 보관하는 스퀀스 컨테이너(sequence container)와, 키를 바탕으로 대응되는 값을 찾아주는 연관 컨테이너(associative contatiner)가 있다.
2.	먼저, 시퀀스 컨테이너의 경우 vector, list, deque이렇게 3가지가 정의되어 있고, 먼저 vector의 경우 가변길이 배열이라고 보면 된다.
	벡터에는 원소들이 메모리 상에서 실제로 순차적으로 저장되어 있고, 따라서 임의의 위치에 있는 원소를 접근하는 것을 매우 빠르게 수행할 수 있다.

[3.	정확히 얼마나 빠르다고?]
1.	컴퓨터 공학에선 어떠한 작업의 처리 속도를 복잡도(complexity)라고 부르고, Big O표기법으로 나타낸다. 
	버블 정렬의 경우 최고차항만 나타내어 O(N^2)인데, 큇고트(Quicksort)알고리즘을 활용하면 O(NlogN)의 복잡도로 연산을 할 수 있다. 
	 물론, 퀵소트가 항상 버블정렬보다 빠른것은 아닌데(계수가 얼마나 붙어있는지 모르기에) N이 정말 커진다면 언젠가 퀵소트가 버블정렬보다 더 빨리 수행되는 때가 발생한다.
2.	여기서 vector의 경우, 임의의 위치에 있는 원소에 접근, 추가, 제거를 O(1)로 수행할 수 있다. 또한 배열처럼 []로 접근하거나, at함수를 이용하여 접근이 가능하고, 맨 뒹 원솔르 추가하거나 제거하는데에 push_back혹은 pop_back을 사용하면 된다.
3.	참고로 맨 뒤에 원소를 추가하는 작업은 엄밀히 말하자면 amortized O(1)이라고 하는데(amortized 분할상환) 
	보통 vector의 경우 현재 가지고 있는 원소보다 더 많은 공간을 항당해놓고 있다. 문제는 할당된 공간이 다 찼을 때 인데, 이때는 큰 공간을 다시 할당하고, 기존의 원소들을 복사할 수 밖에 없다. 따라서 n개의 원소를 모두 복사해야하니 O(n)으로 수행된느데,
	이 O(n)으로 수행되는 경우가 매우 드물기 때문에, 전체적인 평균값으로 O(1)으로 수행됨을 알 수있다. 그리하여 amortized O(1)이라고 부른다. 
4.	vector하고 만능은 아닌 것이, 맨 뒤의 원소를 추가하거나 제거하는 것은 빠르지만, 임의의 위치에 원소를 추가하거나 빼는 경우 그 뒤 원소들을 한칸씩 이동시켜야하기에 n번의 복사가 필요하다.
	즉, 맨 뒤가 아닌 위치에 데이터를 추가하거나 제거하는 작업이 많을 경우, vector를 지양해야한다.
5.	결과적으로 vector의 복잡도를 정리하면
	-임의의 위치 원소 접근([], at): O(1)
	-맨 뒤에 원소 추가 및 제거(push_back / pop_back):amortized O(1); (평균적으로 O(1)이지만 최악의 경우 O(n))
	-임의의 위치 원소 추가 및 제거(insert, erase): O(n) 
	위처럼 작업에 따른 속도차이가 크기 때문에 어떠한 작업을 위해 이 컨테이너를 사용할 지 정확히 인지하고 최적의 컨테이너를 골라야 한다.

[4.	반복자(iterator)]
1.	앞서 반복자는 컨테이너에 원소에 접근할 수 있는 포인터와 같은 객체라고 하였다. 벡터의 경우 []말고 반복자를 사용해서도 마찬가지의 작업을 수행할 수 있는데, 후에 설명할 알고리즘 라이브러리의 경우 대부분이 반복자를 인자로 받아 알고리즘을 수행한다. 
2.	반복자는 컨테이너에 iterator멤버 타입으로 정의되어 있는데, vector의 경우 begin()함수(첫원소가리키는 반복자)와 end()함수(마지막 원소 한 칸 뒤를 가리키는 반복자)를 사용할 수 있다.  
	end(0)가 마지막 원소의 뒤를 가리키는 가장 큰 이유는, begin()==end()로 원소가 없는 벡터를 표현할 수 있게 되기 때문이다. 
 
*/
