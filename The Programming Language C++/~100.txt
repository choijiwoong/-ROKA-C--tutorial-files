	[C++ 둘러보기: 기초]
1.	C++는 정적 타임 언어이기에 모든 개체의 타입을 활용 시점에 컴파일러가 알고 있어야 한다.
2.	auto는 타입을 명시적으로 언급할 필요가 없을 경우 대부분 사용되는데, auto를 사용하지 않는 특별한 이유는 '큰 유효범위 내에서 정의가 이뤄지고, 코드를 읽는 사람에게 타입을 명확하게 보여주고 싶은 경우' & '변수의 범위나 정밀도를 명확히 해야 할 필요가 있는 경우'이다.
3. 	range_based for에서 reference로 값을 순회하고 싶다면 auto& x: v꼴로 사용하면 된다.
4.	&, *, []등의 연산자는 선언자 연산자(declarator operator)라고 불린다. T a[n], T* p, T& r, T f(A)
5.	new와 delete는 아래와 같이 오버로딩이 가능하다. 연산자이기 때문이다.
	void* operatoe new(size_t size){
		void* adr=new char[size];
		return adr;
	}
	
	void operator delete(void* adr){
		delete []adr;
	}
6.	열거형 사용 시 ::를 사용하며, enum과 enum class의 차이는 보다 엄격한 타입을 갖게하는 차이가 있다. 즉 enum은 일반 int처럼 사용이 가능하나 class는 ::를 이용하여 접근해야한다.
7.	코딩 시 My_code와 같은 namespace에 넣어 내가 쓰는 이름들이 std혹은 include한 라이브러리 이름과 충돌하지 않게 할 수 있다. using을 통하여 라이브러리 네임스페이스의 이름에 접근할 수 있다. (using namespace std(using 지시문) 혹은 using std::cout(using 선언문)
8.	클래스 불변속성(class invariant)란 어떤 객체의 상태가 프로그래머의 의도에 맞게 잘 정의되어 있다고 판단할 수 있는 기준을 제공하는 속성을 가리킨다.
9.	예외에 대하여 컴파일 타임에 알 수 있다면 간단한 체크를 통해 컴파일 타임 오류로 이끌어내면 좋은데, 주로 정적 단정 static_assert를 사용한다. 이는 상수표현식constexpr으로 표현될 수 있는 그 어떤 것에도 사용이 가능하다.
	static_assert(A, S) 에서 A가 true가 아니면 오류 메시지로 S를 출력한다. 이는 일반화프로그래밍 매개변수 타입에 대한 단정에 주로 사용된다.
	
	[C++ 둘러보기: 추상화 메커니즘]
1.	기본 제공 타입과 똑같이 작동하게끔 한다는 기본개념의 concrete type은 다른 객체 안에 배치되거나 참조, 초기화와 복사등 여러가지등이 가능해지는데
	기본적으로 RAII(Resource Acquuisition Is Initialization)의 개념을 따르게 한다.
2.	추상 클래스에서 정의된 인터페이스에서 요구하는 함수(순수 가상 함수)는 그를 상속받는 구체 클래스에서 정의가 가능하다. override
	해당 추상 클래스를 사용하는 여러 클래스들은 사용하는 함수 use(Container&)를 사용하므로써 어느 클래스던간에 use는 재컴파일될 필요가 없다는 장점이 있지만 반대로 객체가 포인터나 참조자로만 조작되야한다는 단점 역시 수반한다.
3.	가상함수를 구현하는 통상적인 기법은 컴파일러가 가상 함수의 이름을 (함수를 가리키는)포인터 테이블의 색인으로 변환하게 하는 것이다. 호출자의 구현은 Container내에서 vtbl를 가리키는 포인터의 위치와 각 가상 함수에 사용되는 색인만 알면 된다.
4.	추상클래스에서는 가상 소멸자가 필수적이다.