	[연산자 오버로딩]
1.	operator type() const{ return v; }꼴로 타입변환 연산자 오버로딩이 가능하다. 다만 이는 자제하는 편이 좋으며 최선의 방법은 X::make_int()같은 함수로 초기부터 변환처리를 하는 것이 바람직하다.

	[특수 연산자]
1.	operator[](), operator()()는 non-static 멤버 함수여야 한다. (smart pointer제작에 주로 사용되는_포인터+런타임 오류 체크)operator->()를 오버로딩 하려면 리턴형이 X*형이다. 다만 operator.()처럼 .연산자는 오버로딩 할 수 없다.
2.	operator++()으로 전위를, operator++(int)로 후위를 overloading할 수 있지만, 기본적으로 ptr+1을 가리킬 수 있는지 체크하는 부분, 전위보다 후위가 약간 까다로운 부분을 고려하여 이러한 연산자가 필요하다면 후위를 생략하고 전위만 구현하는 것이 효율적이다.
3.	operator new(), operator delete()로 생성&소멸 연산자의 오버로딩이 가능하지만 전역 new&delete의 오버로딩은 바람직하지 않다. 이들은 this를 갖지 않으며 객체변경을 못하는 implicitly static이다. 다만 저장공간을 제공할 뿐이다. 소멸시 virtual을 고려하여 size_t를 인자로 갖는다.
4.	리터럴을 overloading할 때는 std::string operator"" s(const char* p, size_t n)과 같은 꼴인데, string입력하면 알아서 size_t를 채워준다. 당연하겠지만 기본 제공 정수 타입에 리터럴을 쓰면 ""없이 숫자만 쓰면 된다.
5.	template literal operator은 여러 개의 템플릿 매개변수를 인자로 받아들이는 리터럴 연산자이다. 처음에 _로 시작하지 않는 모든 접미사는 표준 라이브러리용으로 따로 예약되어있기에 정의하는 접미사를 밑줄로 시작하면 향후에 코드문제 발생 가능성이 없다.
6.	friend로 선언된 함수는 접근지시자와 상관없이 클래스의 구현에 접근이 허용된다. A에서 B의 함수를 friend로 선언한다면 B의 friend 함수에서 A로의 접근이 가능하다(템플릿 인자에 friend를 이용할 수도 있다. friend T)
	namespace에서 정의되지 않은 클래스,함수를 friend로 하면 해당 namespace에 포함된다고 가정하고 오류를 발생시키지 않는다. 다만 결국 정의되지 않고, 해당 이름과 같은 함수 혹은 클래스가 namespace바깥에 있다면 이는 직관적으로 당연하게 friend가 아니다. friend를 해당 범위 내에서만 찾지 밖에서 찾지 않는다.
	고로 friend는 소속된 유효 범위 내에서 명시적으로 선언되거나, 그것으로부터 파생된 클래스의 인자를 받아들여야 한다(Argument-Dependent Lookup) friend는 항상 이게 ㄹㅇ필요한가를 생각해야하며 주로 이항 연산자에서 사용된다.

	[파생 클래스]
1.	implementation inheritance(run-time polymorphism, dynamic polymorphism), interface inheritance(compile-time polymorphism, static polymorphism) class hierachy. abstract class has one more pure virtual class with virtual destructor without constructor. (p.s nonintrusive 비침습적)
2.	파생 클래스는 기반클래스의 private에 접근할 수 없다(for 기반과 파생의 구분..). 고로 pubilc만 이용하는 것이 좋은데 다음과 같은 경우를 조심하자. void Manager::print() const{ print(); } 이는 재귀적이라 다음처럼 수정돼야 한다. void Manager::print() const{ Emplyee::print(); }
3.	enum을 이용하여 클래스 내 타입필드를 만드는 것은 컴파일러가 체크할 수 없는 방식으로 타입을 조작한다는 근본적인 취약성이 존재한다. 또한 수많은 파생클래스를 처리하는 대규모 함수안에 묻혀있는 타입필드를 찾는 것은 어렵기에 유지보수문제를 낳는다.
4.	virtual function의 공간오버헤드는 virtual function을 가진 클래스의 각 객체 당 하나의 포인터에 클래스당 1개의 vtbl을 더한 것이다. 명시적 한정으로 정확한 function call이 가능하다.(like 위의 예시)
5.	재정의하려는 함수를 실제로 재정의한 것인지 확신하기 어렵기에 재정의하지 않을 함수에 virtual을 불필요하게 사용하지 않는다. 이러한 문제를 해결하기 위해 virtual, =0, override(선언이 끝나고 맨 마지막에 등장, contextual keyword), final같은 제어장치를 사용할 수 있다. 
	virtual시 추가적인 파생 클래스의 필요성, 함수 재정의로 목적을 달성할 수 있는지, 정확한 재정의가 쉬운지 등을 생각해야 한다. 다음과 같이 추가적인 재정의를 방지할 수 있다. Type type() override final;_파생&재정의 금지.
6.	아래와 같이 하면 Vector가 std::vector로부터 아무 생성자도 상속받지 못한다. using std::vector<T>::vector을 통해 명시적으로 생성자를 상속한다고 표현해야한다. 다만 아무 데이터 멤버도 추가되지 않는 간단한 경우에만 상속 생성자를 사용해야하는데 새로운 멤버들에 대해서 initialization을 하지 않기때문이다(하나하나{}로 하면 되긴하는데 너무 까먹을거같다..)
	template<typename T>
	struct Vector: std::vector<T>{
		using size_type=typename std::vector<T>::size_type;
		T& operator[](size_type i) { return this->at(i); }
		const T& operator[](size_type i) const{ return this->at(i); }
		//using std::vector<T>::vector;//생성자를 상속한다! 자동생성된 default constructor사라짐.
	};
7.	convatiant return rule은 포인터나 참조자인 반환타입에 대하여 Derived->Based선에서 변경이 가능하다는 것이다. 주로 정확한 타입을 알지 못하는 상태에서 새로운 객체를 생성하는 것이 쓸모 있는 경우 사용한다.
8.	access modifier을 나누어서 정의하는 것은 multi threading convironment에서 rearrage가능성이 있다. protected는 파생하면 모든 protected 멤버에 접근이 가능하기에 악용가능성이 있어 안전한 modifier가 아니다. 기본 데이터 타입은 private가 맞으며 protected를 사용해야한다면 차라리 private로선언된 공통된 데이터 클래스를 갖는 것이 좋다.
	protected는 주로 파생 클래스에서 사용될 연산을 지정하는데에 사용된다. protected class B의 public과 protected는 파생클래스 D의 멤버함수와 프렌드 등에서 사용이 가능하다.
9.	가상함수를 구현하는 통상적인 기법은 컴파일러가 가상 함수의 이름을 (함수를 가리키는)포인터 테이블의 색인으로 변환하게 하는 것이다. 호출자의 구현은 Container내에서 vtbl를 가리키는 포인터의 위치와 각 가상 함수에 사용되는 색인만 알면 된다.
10.	추상클래스에서는 가상 소멸자가 필수적이다. 다이아몬드 상속 시 Based를 virtual로 상속받으면 사용 가능하다.
11.	pointer of member는 &Std_interface::suspend와 같이완전히 한정된 클래스 멤버 이름에 주소추출 연산자&를 적용하면 얻어질 수 있다. 이는 이름을 모르는 상태에서 함수를 참조해야할 때 사용한다. 함수를 가리키는 포인터를 통해 호출된 함수는 virtual일 수 있다는 점을 유의해야한다.
12.	static 멤버를 가리키는 포인터는 통상적인 포인터일 뿐이다. class Task{ static void schedule(); }; 		void (*p)()=&Task::schedule;//OK 	void (Task::* pm)()=&Task::schedule;//ERROR pointer of member에 common pointer가 assign되었다.
13.	contravariance(반변성)이란 pointer of Based를 pointer of Derived에 안전한 대입이 가능하지만 그 반대는 안된다는 것이다.

	[클래스 계층 구조(class hierachy)]
1.	오래된 코드에서 흔한 구현상속을 사용하는 class hierachy는 Ival_box처럼 가장 Based인 BBwidget을 상속하여 구현할 수 있지만, BBwidget이 변경될 시 재컴파일 및 수정을 해야한다는 단점이 있다. 또한 버전(Imperial Bananas, Liberated Software, Compiler Whizzed)에 따라 Widget이 달라지면 더욱 복잡해진다.
	고로 인터페이스 상속을 사용하여 이러한 문제를 해결한다. public 인터페이스 상속과 protected 구현 상속을 동시에 사용하여 재정의하는 다중 상속은 보편적이다.
2.	클래스 계층도에서 점선은 protected상속을 나타내며 protected 기반 클래스는 구현에 속한다고 간주하기에 일반 사용자는 인터페이스를 통해 접근이 불가능하다. 하지만 이러한 interface inheritance도 버전관리에 대해서는 implementation inheritance와 같은 문제를 갖는다.
	고로 버전별로 별도의 이름을 갖는 인터페이스를 정의하거나, 인터페이스를 구현하는 클래스가 별도의 이름을 갖게 하거나, 인터페이스를 최대한 구현 후 based되는 class를 상속할 수 있다. p.679
3.	추상 클래스 설계에는 거의 모든 사용자 코드가 구현에 가해진 변경에서 보호되며, 그런 변경 후에도 재컴파일을 요구하지 않는다. 또한 Ival_box계층 구조에 명시적으로 지정된 기능들만 user의 접근이 가능하기에 우현히 구현기능 사용의 염려또한 사라진다. 특정 구현의 고유 기반 클래스로부터 아무것도 암시적으로 상속되지 않기 때문이다.
4.	상속은 shared interface(run-time polymorphism, interface inheritance), shared implementation(implementation inheritance)중 하나를 제공하는 것을 목표로 하는데 가변상태가 없는 모든 클래스는 다중 상속 관계망 내에서 인터페이스로 사용되도 상당한 복잡성이나 오버헤드를 유발하지 않는다.
5.	다중 구현 클래스는 여러 개의 추상 클래스를 가져 프로그래머가 다수의 전달 함수를 작성해야하느 수고를 절어주지만 경우에 따라서 구현 세부 사항을 은닉하려는 목표와 충돌 될 수 있다. 
	다중 구현 시 같은 이름의 함수같은 경우 Debug_info di1=Satellite::get_debug();	Debug_info di2=Displayed::get_debug();	return merge_info(di1, di2); 처럼 파생 클래스내에서 새 함수를 정의하여 해결할 수 있다. 아니면 명시적한정 사용하던가!
	virtual로 같은 이름 함수를 사용하는 방법도 있는데(매핑 레이어) 이는 인터페이스 계층을 추가하는 기법과 동일하다. 다른 방법으론 하나를 const함수로 바꾸는 것도 나쁘지 않다. 중간 클래스를 작성해도 된다. 다만 방금말한 const방법이 사용가능하다면 보다 나은 결과를 기대할 수 있다.
6.	기반 클래스의 반복사용(다이아몬드 상속구조에서 이름같은 virtual function override)의 경우 하위 객체 두개를 갖거나, 한개를 갖게끔 할 수있다. 두개를 갖게 하는 방법은 다이아몬드 하위 write()함수에서 Transmitter::write()와 Receiver::write()를 종시에 사용하여 작정할 수 있고,
	한개를 갖게 하려면 virtual based class로 만들어버리면 된다. 즉 상속 시 class Transmitter: public virtual Storable{}처럼 한 뒤 class Radio: public Transmitter, public Receiver{}로 두개의 virtual based class를 상속하여 사용하면 된다. 이는 두 개의 클래스가 데이터를 공유하는 경우에 사용된다.(아니면 또 명시적 한정쓰던가!)
	생성자에서 공유 객체에 필요한 메모리를 챙겨두었다가 초기화하고 공유객체를 가리키는 포인터(shared_ptr)를 제공하면 된다. 당연히 이런 포인터들은 오프셋이 될 것이기에 Receiver이나 Transmitter하위 객체 중 하나를 기준으로 포인터를 고정하여 최적화 할 수 있지만, 여튼 각각의 가상 기반 클래스에 대해 하나의 워드(shared_ptr)에 해당하는 공간오버헤드를 예상해야 한다.
7.	C++은 기반클래스의 생성자가 딱 한번 호출되게 보장해주지만 혼란을 피하기 위해 모든 가상 기반 클래스의 생성자는 완전한 객체(말단의 파생 클래스)에서 호출된다. (이해할거같은데 만약 못하면 p.694참조) 소멸자는 이러한 순서를 신경쓰지 않아도 되는것이 생성자 순서에 의존하여 역순으로만 호출하기 때문이다.
8.	추상 클래스를 공유데이터 없이 인터페이스로 활용하는데에 인터페이스 클래스를 복제하거나(:public ~) & 인터페이스 클래스를 virtual로 만들어서 그것을 언급하는 계층 구조내의 모든 클래스 사이에서 간단한 객체를 공유하게하거나(:public virtual~) 총 2가지의 방법이 있다. (virtual없이 하면 구조가 복제된다)
	둘의 논리적인 차이는 복제된 설계에서는 상위클래스로 암시적 변환이 불가능 하다는 것이다.p. 698의 계층도 참고. 근데 그냥 팩토리함수(내부적해결) 만들거나 가상생성자(알아서사용)쓰면 문제 해결됨.
	void f(Ival_slider* p);
	void g(BB_popup_ival_slider* p){ f(p); }//Popup_ival_slider::Ival_slider인지 BB_ival_slider::Ival_slider인지 모호해진다. 상위 객체가 복제되었기에!!
9.	하나의 window를 공유하는 두 class에서 각기 재정의를 한다면, 해당 window라는 인터페이스의 일관성이 사라지기에 그러한 virtual상황에서의 각자 override는 Mixin클래스로 두 클래스를 상속받아 모든것(각자의 override)를 한번에 재정의하여 override해야한다.
	이렇게 가상 기반 클래스에 대한 구현의 일부를 제공하는 클래스를 종종 Mixin클래스라고 불린다.