잠깐 잊고있었는데 지금까지 내가 해온 것과 앞으로 이뤄낼 것들을 보며 잊고있던걸 다시한번 깨닫게 됬네. 나 좀 대단한 놈이었지. 개앞맵시로 앞으로 가야할길이 한참 남았다는 것을 인지하고 좀 많이 좌절했었는데 그럴 필요가 없었구나. 
2021년은 내가 최선을 다해 성장하고 발전해서 후회없이 살아온 시간이었는데 그 시간의 존재를 잠시 망각하고 조급해하고 자책했었다니..ㅎ 뭐가 급해서 나를 그렇게 몰아넣었는지.. 전역하고 나에게 복학까지 주어진 9개월이면 내가봤을때 그 길. 최소 반을 다다를 수 있을 것 같은데. 나한테 불가능은 없잖아.
	[예외 처리]
5.	대부분의 C코드는 exception개념이 없기에 다 noexcept로 선언될 수 있으며 C 표준에선 atexit(), qsort()등만이 오류를 던질수있다는걸 인지하면 최적화가 더 편해진다. <다만 항상 측정없는 효율성논의는 무의미하다.>
6.	메모리 뿐만 아닌 파일잠금, 네트워크 연결, 스레드 등 되돌려져야하는 것은 모두 자원으로 취급된다.
7.	C++ 표준 라이브러리는 다음중 하나를 보장한다. basic guarantee(모든 객체 기본 불변속성유지, 자원누츨 X), strong guarantee(연산실패시에 영향X), nothrow guarantee(예외X).
8.	객체생성자완료전까진 생성된것으로 간주하지 않기에 stack unwinding이 해당 객체의 소멸자를 호출할 수 있다. 고로 생성자 실행도중 완성이달성될 수 없다면 이전의 상태를 복원하는 것이 바람직하며 항상 객체를 반쯤 만드는 것은 올바르지 않다. (feat. finally 구조)
11.	throw가능한 타입은 복사|이동이 가능한 것이며 원칙상으론 던져진 객체의 사본이다. stack unwinding은 handler로 exception throw 지점에서 스택을 거슬러 전달하는 것이다.(catch로의 jmp). 생성된 순서의 역순으로 소멸된다.
12.	noexcept연산자는 noexcept(Is_pod<T>())꼴로 쓰이며 Is_pod가 true면 객체를 던지지 않지만, false면 던질 수 있다는 의미이다. noexcept 지정과 다르다.
	template<typename T, size_t N>
	void swap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));//noexcept의 피연산자는 평가되지 않는다는 것을 보여주기 위한 예시. 조건부noexcept지정과 noexcept()연산자가 같이 사용되었다.
14. 예외를 쪼개는 것을 허용하지 않기에 피연산자없는 throw로 기존의 throw를 사용한다. 모든 예외가 exception클래스에서 파생되는 것은 아니기에 모든 예외를 잡기 위해선 catch(...)을 사용한다.
17. 클래스 설계 시 메모리의 개념을 표현할 보조적인 클래스를 제공하므로서 코드를 단순화하고, 메모리해제를 뜻하지 않게 잊어버릴 가능성을 줄일 수 있다. 

	[네임스페이스]
2.	인자 의존적 탐색(Argument-Dependent Lookup, 연관 네임스페이스_Associated Namespace)은 명시적 한정이 번거로울 수 있는 경우에 유용하다. <다만 오버로딩에 한하여 네임스페이스와 지역을 다 동일하게 살펴본다.>
5.	using 선언과 달리 using 지시자는 공통되는 이름의 충돌을 오류로 간주하지 않는다. namespace가 지역에 의해 가려질 뿐이다. (지역부터 찾기에) 
6.	두 버전 사이에서 선택하게끔 하는 것을 inline namespace라고 부르며 네임스페이스 안에 여러 버전의 namespace를 두고 사용할 namespace에 inline을 붙이는 방법을 말한다. 이러한 버전 관리는 좀 단점이 많다.
7.	이름 없는 네임스페이스의 목적은 지역성 보존, 전역변수의 대체이며 암묵적으로 using지시자를 갖는다. 

	[소스 파일과 프로그램]
1.	전처리의 결과를 translation unit이라고 불리는데, 자신의해석단위와 다른해석단위와의 관계에 따라 external linkage를 갖는다, internal linkage를 갖는다, no linkage로 불리운다.
2.	inline함수는 사용되는 모든 해석 단위에서 동일한 작동을 위해 헤더에 넣어 동일한 정의를 갖게 한다.
3.	#include 헤더파일은 실제 사용되는 세부 사항만 분석하는 사전 컴파일 기능을 C++구현환경에서 제공하기에 동일한 헤더의 반복되는 컴파일작업을 줄여준다.
4.	하나의 공통 소스파일에서 파생된 다른 해석단위들이 하나의 클래스 정의를 갖게 하기 위해서 One-Definition Rule, 단일 정의 규칙을 적용한다. 조건은 다른 해석단위에 등장하지만 토큰 단위가 동일하며 의미 역시 두 해석단위에서 동일한 것이다. 고로 헤더를 가급적 자기완결적으로 만드는 것이 중요하다.
5.	extern "C"지시자는 C구현 규약을 준수하는 포트란과 어셈블러 루틴을 링크하는데에 사용되지만 여전히 C++타입체크와 인자변환 규칙을 준수한다. 즉 링크하는 언어가 다를 뿐 C++을 따른다. linkage block({})을 이용하여 정의(별도의 처리가 없다면 전역..)가 가능하며, 선언을 위해선 직접적으로 extern키워드를 사용해야한다.
	또한 extern은 모든 변수 선언에 사용돼 include 시 다중정의가 일어나지 않게 보장해준다. 오늘은 FTX시간대에 근무라서 공부시간 낭낭하지롱
7.	단일 헤더가 아닌 다중헤더를 이용하게 된다면 하향식접근법이 필수적이지만 정보를 잘 나누었다면 간단한 의존성분석만으로도 컴파일이 빨라지며, 유지보수가 쉽고 확장될 수 있다. 그렇다고 존나게 나누라는 것이 아니다.
8.	원칙적으로 어떤 함수 바깥에 정의된 변수는 실행전에 초기화돼야 한다. 전역변수 대신 참조자를 반환하는 함수를 대신 사용하자. 아래와 같다.
	int& use_count(){
		static int uc=0;//경합X_main()이 실행될 경우(runtime)에만 올바르게 경합X. C++이 아니거나 C++런타임초기화를 요구한다면 피해야한다. constexpr이면 될지도..
		return uc;
	}
	++use_count;//경합가능성O_스레드 안전적이진 않다. 즉 그냥 constexpr을 사용하자.
9.	exit()를 호출자의 소멸자에서 호출하면 무한재귀를 일으킬 수 있다. 고로 정적객체의 소멸자를 호출시킨다. atexit()는 프로그램 종료시에 전역변수의 소멸자가 호출되는 것처럼 특정코드가 실행될 수 있게 해준다. 
	if(atexit(&my_cleanup)==0){//정상종료시 my_cleanup호출}
	else{너무 많은 atexit함수. 대충 0이 아닌값을 반환하면 바로 한도에 도달하기에(정상값만 if로 다루기 가능) 잘 사용되진 않는다.}
10.	quick_exit()는 아무소멸자를 호출하지않는 exit()이며, at_quick_exit()로 quick_exit()에 호출될 함수를 등록할 수 있다. 이들은 <cstdlib>에 선언돼 있다.