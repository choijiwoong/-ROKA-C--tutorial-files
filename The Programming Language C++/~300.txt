	[타입과 선언]
15.	auto를 사용하여 타입 오류의 탐지를 지연시킬 수 있다.(넓은 유효범위를 지칭하다가 명시적으로 타입을 언급함으로서) auto complex<double>(d)+7;(complex<double>로 추론) double min=complex<double>(d)-9;(d를 scalar로 가정)
16.	레퍼런스는 auto&로 받지 않는 일반 auto일 경우 일반타입으로 추론한다. (p.s auto_를 통해 받는 것이 리스트가 아니라면_ {}대신 =을 사용하자)
17. 접미사 반환 타입 문법으로 반환타입 auto를 명시적으로 지정해줄 수 있다(인자타입을 통해) auto operator+(const Matrix<T>& a, const Matrix<U>& b)->Matrix<decltype(T{}+U{})>
18. 객체의 수명은 자동(함수호출시 스택 프레임이 자동객체 보관, 유효범위 이탈시 소멸), 정적(프로그램 종료시), 자유 저장 공간(new, delete로 직접 제어), 임시 객체(자신이 속한 전체 표현식이 종료될 때), 스레드 로컬(스레드생성~소멸시) 객체로 분류된다.
19.	using 선언자와 지시자를 잘 구분하면 되고, 유용한 별칭들(int16_t같은)은 <cstdint>에서 찾을 수 있다.

	[포인터, 배열, 참조]
1.	dereferencing, indirection by *. 기본제공포인터를 이용하여 독립적으로 할당하고 가리킬 수 있는 최소의 객체는 char이다. 즉, bool역시 char만큼의 크기를 차지한다. bool을 조밀하게 다루려면 bit field, bit set등을 이용하면 된다.
2.	void*는 보통 하드웨어 자원이 다뤄지는 시스템의 최하부 수준에만 존재한다. (함수나 멤버를 가리키는 포인터는 void*에 대입이 불가하다.)
3.	리터럴 nullptr은 딱 하나의 값이며 (C에선 (void*)0으로 표현한다)
4.	인터페이스 안에서의 배열은 피해야 하는데, 포인터로서의 암시적 변환의 불안정성 때문이다.
5.	문자열 리터럴은 함수에서 안전하게 반환되게끔 정적으로 할당되기에 다음과 같은 반환이 가능하다. const char* error_message(int i){ returrn "range_error"; } error_message함수 호출뒤에도 사라지지 않는 정적인 문자열이다.
6.	배열에서 a[j]==j[a]이다. a.operator[](j)를 호출하는 것이기에 3["Texas"]=="Texas"[3]=='a'가 성립한다. 이는 저차원 코드가 아닌 이상 쓸모가 없다.
7.	int good[3][5]; int ouch=good[1,4];는 good[1]의 타입을 가지는 int* good[4]이다. (good[1][4]인데 int*인) 참고로 다차원 배열의 첫 원소주소를 전달할때 v[0]을 전달해도 되지만, 타입오류를 방지하기 위해 v[0]..[0]으로 정확히하자.
8.	char *const pc;(const pc) char const* pc;(char const) const char* pc;(char const)혼동하지 말기. pc바로앞에 const있으면 주소변경불가, 나머지 const char가리키는 포인터. (feat. const function)
9.	우변값 참조자로 객체를 참조한다고 우변값처럼 사용되는 것이 아니라 실제로 이동된 것이기에 통상적인 방식의 접근이 가능하다.
10.	참고자에 대한 참조자 사용규치으로 reference collapse가 있는데, int && & r=i;는 허용되지 않는다.
11.	가리키는 객체가 변경할 것 같다면 pointer을 사용하고(고로 reference배열은 오류처리) 어떤 이름이 항상 동일한 객체를 참조하게 만들고 싶다, 혹은 사용자정의 연산자를 사용하고 싶다면 참조자를 사용하면 된다.(여러 이름이 한 객체 참조) 
	(객체 없음(nullptr)이 필요할 때를 제외하고는 참조자를 인자로 선택하자.)

	[구조체, 공용체, 열거형]
1.	NASM에서 배웠듯이 아키텍처에 독립적인 경계에 할당하기에 struct크기가 그 멤버들의 크기의 합과 같지 않다. 메모리가 낭비되는 느낌이 들 수 있지만 가장 큰 순서부터 크기순으로 멤버들을 정렬만해도 공간 낭비를 최소화 할 수 있다.(struct에 멤버 정의 순서)
	또한 접근지정자를 여러개 사용하면 그거 나름대로 또 struct구조가 바뀔 수 있다. C이전의 이유들 때문에 동일한 유효 범위 내에서 같은 이름을 가진 struct와 struct가 아닌 타입을 선언할 수 있다.(오류가 아니다 struct food; int food;)
2.	멤버들을 순서대로 초기화할것이라면 default constructor가 있기에 굳이 생성자를 만들지 않아도 된다. Point points[3]={{1,2}, {2,3}, {5,6}}; 
	참고로 기본제공배열과 달리 std::array는 초기화 식의 길이를 근거로 원소를 추정할 수 없기에 array<Point> point={{1,2}, {3,4}, {5,6}};이 불가하다. 항상 array<Point, 3>처럼 size를 전달해야 한다.
3.	재래식 데이터(Plain Old Data)는 단순 데이터로서 다룰 수 있는 객체이다. 구조는 최대한 단순해야하는데 어떠한 변수가 본체혹은 상속받아 하나만 있으면 된다. ANSI C와 호환되는 데이터이다. 주로 <type_traits>의 is_pod<T>::value를 통해 POD인 경우에만 memcpy로 copy하는 등 약간의 최적화들이 가능하다.
4.	비트 필드는 워드의 일부에 비트단위 논리연산자를 사용하기 위한 것으로 0의 크기를 가진 비트필드는 새로운 할당 단위에서 시작한다는 의미로 다음 필드가 워드 경계에서 시작한다는 의미를 갖는다.
5.	공용체는 타입 변환용으로 사용하면 안되는게 캡슐화(생성자만들고..등등)하지 않는 이상 비트단위의 대응관계가 동일하지 않기 때문이다. 컴퓨터에 따라 같은 자료형이더라도 차지하는 메모리공간의 크기가 다를 수 있으며 정수가 홀수 주소를 가질 수 없는 경우도 있기 때문이다. 즉 오류에 취약하다. 매우.
	new나 delete등을 간단한 필드를 가지는 union에 사용하는것은 문제가 되지 않지만, string, complex<double>등 조금만 복잡해줘도 어떤 기본, 복사 생성자를 사용해야하는지, 대입은 어떻게 해야하는지 등 여러 구현상의 난관이나 오류를 맞이하게 된다. 이를 그나마 줄이기 위해 union에서 최대 1개의 맴버에 대해 클래스 내부 초기화 식을 사용할 수 있다.
6.	익명 union{}은 기존 union의 타입변환 오용문제를 극복할 수 있도록 enum과 함께 사용되는 것이 대표적인 사용예시이다. 이름언급없이 사용할 수 있으며 각각 getter와 setter에서는 타 타입의 생성자와 소멸자를 포함한다(tagged union 또는 discriminated union이라고 불린다). 단순히 메모리 공간 절약에만 활용하자.
7.	열거형에서의 타입은 underlying type(기초타입)이라고 불리운다. 이는 명시적으로 선언될 수 있으며 enum class Warning: char{green, yellow, orange, red};//sizeof(Warning)==1가 예시이다. condition사용시 namespace를 명확히하자._if(y==E2::a)
	열거형은 사용자정의타입이므로 |및 &연산자 사용 혹은 오버로딩이 가능하다. 또한 기초타입을 지정하지 않을 경우에 enum E1{dark, light}; enum E2{a=3, b=9};과 같이 정의없이 바로 선언할 수 있으나 이때의 열거형의 범위는 복잡한 알고리즘에 의해 결정된다. enum E3{min=-10, max=1000000};//[-1048579:1048575]

	[문장]
1.	for(for-init-statement consition; expression), for(for-init-declaration(초기화 되지 않은 단일 변수의 선언): expression)으로 음..용어적으로 표현이 가능하다. 또한 switch에서 딱 한가지 case만들 갖아야 하는상황에서 default를 사용하면 변환을 통해 case로 들어가야 하는 경우에 default로 빠져 오류로 간주할 수 있다.
2.	range-based-loop에서 하나의 원소를 수정하려면 원소 변수가 참조자여야 한다.
3.	초기화 할 수 있는 값이 생기기 전까지 선언을 삼다가 선언과 동시에 초기화해주는 것이 효율적이다.
	
	[표현식]_탁상용 계산기를 참고하자.
1.	object는 클래스 객체를 만드는 표현식이다. expr은 리터럴을 포함한 표현식이다. capture-list는 상황 정보 의존성을 지정하는(비어있을 수 있는) 리스트다. stmt_list는 (비어있을수있는) 문장의 리스트다.
2.	::name(전역 연산자), dynamic_cast<type>(expr)_런타임 체크 변환, static_cast<type>(expr)_컴파일 타임 체크 변환, reinterpret_cast<type>(expr)_미체크 변환, const_cast<type>(expr)_const 변환, sizeof... name_매개변수 묶음의 크기, alignof(type)_타입의 정렬