	[타입과 선언]
15.	auto를 사용하여 타입 오류의 탐지를 지연시킬 수 있다.(넓은 유효범위를 지칭하다가 명시적으로 타입을 언급함으로서)
18. 객체의 수명은 자동(함수호출시 스택 프레임이 자동객체 보관, 유효범위 이탈시 소멸), 정적(프로그램 종료시), 자유 저장 공간, 임시 객체, 스레드 로컬 객체로 분류된다.

	[포인터, 배열, 참조]
1.	기본제공포인터를 이용하여 독립적으로 할당하고 가리킬 수 있는 최소의 객체는 char이다. bool을 조밀하게 다루려면 bit field, bit set등을 이용하면 된다.
4.	인터페이스 안에서의 배열은 피해야 하는데, 포인터로서의 암시적 변환의 불안정성 때문이다.
5.	문자열 리터럴은 함수에서 안전하게 반환되게끔 정적으로 할당되기에 다음과 같은 반환이 가능하다. const char* error_message(int i){ returrn "range_error"; } error_message함수 호출뒤에도 사라지지 않는 정적인 문자열이다.
6.	배열에서 a[j]==j[a]이다 이는 저차원 코드가 아닌 이상 쓸모가 없다.
7.	int good[3][5]; int ouch=good[1,4];는 good[1]의 타입을 가지는 int* good[4]이다. (good[1][4]인데 int*인)
8.	char *const pc;(const pc) char const* pc;(char const) const char* pc;(char const)혼동하지 말기.
9.	우변값 참조자로 객체를 참조한다고 우변값처럼 사용되는 것이 아니라 실제로 이동된 것이기에 통상적인 방식의 접근이 가능하다.
10.	참고자에 대한 참조자 사용규칙으로 reference collapse가 있는데, int && & r=i;는 허용되지 않는다.
11.	가리키는 객체가 변경할 것 같다면 pointer을 사용하고(고로 reference배열은 오류처리) 어떤 이름이 항상 동일한 객체를 참조하게 만들고 싶다, 혹은 사용자정의 연산자를 사용하고 싶다면 참조자를 사용하면 된다.(여러 이름이 한 객체 참조) 
	(객체 없음(nullptr)이 필요할 때를 제외하고는 참조자를 인자로 선택하자.)

	[구조체, 공용체, 열거형]
1.	struct 정의 시 크기가 가장 큰 순서부터 멤버를 정렬하자
2.	기본제공배열과 달리 std::array는 초기화 식의 길이를 근거로 원소를 추정할 수 없기에 array<Point> point={{1,2}, {3,4}, {5,6}};이 불가하다. 항상 array<Point, 3>처럼 size를 전달해야 한다.
3.	재래식 데이터(Plain Old Data)는 주로 <type_traits>의 is_pod<T>::value를 통해 POD인 경우에만 memcpy로 copy하는 등 약간의 최적화들이 가능하다.
4.	0의 크기의 비트필드는 새로운 할당 단위에서 시작한다는 의미로 다음 필드가 워드 경계에서 시작한다는 의미를 갖는다.
5.	공용체는 타입 변환용으로 사용하면 안되는게 캡슐화(생성자만들고..등등)하지 않는 이상 컴퓨터마다 비트단위의 대응관계가 동일하지 않기 때문이다. 이러한 단점을 그나마 줄이기 위해 union에서 최대 1개의 맴버에 대해 클래스 내부 초기화 식을 사용할 수 있긴하다.
6.	익명 union{}은 기존 union의 타입변환 오용문제를 극복할 수 있도록 enum과 함께 사용되는 것이 대표적인 사용예시이다. 각각 getter와 setter에서는 타 타입의 생성자와 소멸자를 포함한다(tagged union 또는 discriminated union이라고 불린다). 단순히 메모리 공간 절약에만 활용하자.
7.	enum class Warning: char{green, yellow, orange, red};기초타입 지정이 가능하다. 기초타입을 지정하지 않을 경우 열거형의 범위는 복잡한 알고리즘에 의해 결정된다.

	[문장]
2.	range-based-loop에서 하나의 원소를 수정하려면 원소 변수가 참조자여야 한다.
3.	초기화 할 수 있는 값이 생기기 전까지 선언을 삼다가 선언과 동시에 초기화해주는 것이 효율적이다.