	[표현식]
3.	문자의 시퀸스 중 가능한 한 긴 것이 토큰으로 만들어지기 위해 선택; Max Munch Rule이라 부른다(ex. a+++1 == a++ +1) 참고로 a++은 좌변값이 아니다.
5.	객체의 읽기와 쓰기를 동시에 처리하는 표현식은 명확하게 정의해주는 단독 연산자를 사용하거나, ,&&||등으로 명시적으로 표현할 때만 작성해야한다.(v[i]=i++; 정의되지 않은 결과!)
7.	상수표현식을 이용하여 초키화가 컴파일 타임에 수행될 경우 멀티스레드 시스템에서 데이터 경합을 방지할 수 있다. (재귀적 구조나 교착상태가 아닌이상 static 지역변수의 초기화는 데이터 경합으로 이어지지 않는다. 즉 C++구현은 static초기화를 보호한다.)
8.	constexpr생성자를 가진 클래스를 literal type이라고 부른다. 생성자의 본체는 비어있어야하며 모든 맴버가 상수 표현식에 의해 초기화돼야 한다. (const보다 constexpr이 더 큰 개념)
9.	주소 상수 표현식에서 전역변수같이 정적으로 할당된 객체의 주소의 값은 컴파일러가 아닌 링커에 의해 할당되기에 컴파일러는 그 값을 알 수 없다. constexpr const char* p1="asdf"; constexpr const char* p2=p1+2;//ERROR!

	[선택 연산]
6.	대규모 객체를 얻기 위한 목적이라면 move를 사용하면 좋다. 또한 new는 할당된 객체의 크기를 알 수 있어야 하기에 정적 객체보다 약간 더 많은 공간을 차지한다. 이는 작은 다수의 객체저장시 문제가 된다. 웬만하면 그냥 지역변수 사용하자.
7.	new연산자를 오버로딩하기보단 operator news()를 추가정의하는 방식이 더 좋다.
8.	operatoe new()에 추가 인자를 전달하는 new(buf) X문법을 placement syntax라고 한다. placement delete는 가비지 컬렉터에게 delete된 포인터가 더이상 안전하게 파생되지 않는다는 점을 알려주는 것 외에 아무일도 하지 않는다.
9.	noexcept버전의 new와 delete를 사용할 수 있다. int* p=new(nothrow) int[n];, operator delete(p, nothrow);
11.	무한정리스트(unqualified list)_{}는 무한을 뜻하는 것이 아니라 예상되는 타입이 명확히 알려진 경우에 사용한다.
13.	람다에서의 선택적인 mutable지정자는 람다 표현식의 본체가 람다의 상태를 변경할 수 있는지를 알려준다. 람다는 자신의 호출자보다도 오래 살아남을 수 있기에 값에 의한 캡쳐[=]를 사용하는 것이 좋다.
14.	아무것도 캡쳐하지 않는 람다는 적절한 함수포인터에 대입될 수 있다. 람다의 타입은 function<>을 이용하여 명시하는 것이 아닌이상 추론이 안되기에 재귀적인 사용이 불가능하다.

	[함수]
1.	attribute로는 [[noreturn]]과 final(상속방지), [[carries_dependency]]_memory_order정보가 포한되어있다_이 있다.
3.	생성자는 기술적으로 함수가 아니며 소멸자는 오버로딩될 수 없다. 둘의 주소는 알아낼 수 없다.
13.	함수가 호출될 때 유효하리가 예상하는 논리적 기준인 precondition(~을 반환), 반환할때 유효하리라 하는 기준 postcondition(반환값을 ~한 값)을 고려하여 경우별로 보다 효율적인 함수 설계를 하자.(호출자를 신뢰, 신뢰X등등..)
14.	함수 포인터에 초기화 혹은 대입하므로써 오버로딩함수의 주소를 얻을 수 있고, noexcept함수의 경우 noexcept포인터로 받을 수 있다. 또한 함수포인터는 함수링크를 고려해야하기에 타입별칭이나 링크관계지정이 등장할 수 없다.(extern, using pv=func~)
16.	pragma는 표준이 제공하는 것을 넘어서는 기능을 제공하기도 하며 이는 최대한 피하자.(운영체제 별 컴파일러 기능)

	[예외 처리] exception safety guarantee, Resource Acquisition Is Initialization
4.	예외를 사용할 수 없는 경우로는 임베디드 시스템에서 시간 핵심인 구성에서는 catch전파시 소요시간이 균일하지 않기에 사용을 못하다.