	[특수화]
1.	가장 특수화된 버전이 다른 버전에 디해 우선선택되며, C++은 함수에 대한 완전한 특수화만 지원하기에 부분적 특수화를 할 만한 경우에 오버로딩을 사용한다. 오버로딩과 특수화는 다른데, 아무 인자도 받아들이지 않는 template함수주에 선택하는데에 함수 특수화를 사용할 수 있다. 오버로딩이었다면 dummy인자가 필요했을 것이다.

	[인스턴스화]
1.	생성된 specialization과 프로그래머에 의해 명시적으로 작성된 specialization을 구분해야할 때는 각각 generated specialication, explicit specialization(user specialization)이라고 부른다.
2.	클래스 템플릿의 인스턴스화는 그것의 모든 멤버함수의 인스턴스화를 의미하진 않는다. 즉, 연산이 필요한 List<string>::sort()는 인스턴스화 되지만, 아직 연산이 안된 List<Glob>::sort()는 인스턴스화되지 않는다
3.	인스턴스화의 수동제어의 목적은 중복되는 인스턴스화를 제거하거나, 문제를 제거하기 위해 어떤 인스턴스화 시점이 사용되는지 정확히 알아내는 것이다. 이때 사용되는 명시적 인스턴스화 요청은 template키워드(<>없이)가 접두사로 붙은 특수화 완전한 선언이다. template class vector<int>; 이때 모든 멤버함수를 인스턴스화한다.
4.	컴파일러는 개별적인 컴파일 단위에서 다중 인스턴스화를 진단하지 않기에 다중 인스턴스화(template+완전한선언문)는 피해야한다. 이를 보완하기 위해 extern template을 사용하는 추세이며 하나의 특수화에 대해 하나의 명시적 인스턴스화를 만들고 다른 해석단위에서 쓰기 위한 것이다.
5.	name binding은 템플릿 내에서 명시적,암시적으로 사용된 각각의 이름에 대한 선언을 '템플릿 정의의 상황정보', '인자 타입 선언의 상황 정보', '템플릿 사용의 상황정보'를 기반으로 찾는 과정이라고 한다(사용하기위해). 템플릿 매개변수에 대한 성향에 따라 dependent name(인스턴스화시점에 바인딩), nondependent name(템플릿 정의 시점에 바인딩)으로 구분한다.
6.	dependent name은 실제인자타입이 타입추론규칙에 의해 T에 의존하거나, 호출된 함수가 타입추론규칙에 의해 T에 의존하는 매개변수를 가지면 의존적인 이름으로 구분한다. 기본적으로 외존적인 이름은 타입이 아닌 뭔가에 이름을 붙이는 것으로 가정되기에 의존적이름을 타입으로 사용하려면 typename을 명시적으로 사용해야한다.
7.	타입에 이름을 붙이는 것으로 가정된다는 것을 명시적으로 기술하기 위해 typename을 사용하는 경우와 비교시 어떤 이름이 템플릿에 이름을 붙이는 것으로 가정된다고 명시적으로 기술하기 위해 template을 사용하는 경우는 매우 드물다. 그냥 typename은 한정 이름앞에 등장하고, template은 템플릿 이름 앞에 등장한다.
8.	정의시점바인딩 즉, 템플릿 인자에 의존하지 않는 이름은 템플릿에 존재하지 않는 이름과 똑같이 취급되기에 정의가 템플릿정의보다 늦으면 고려를 안하며, 인스턴스화시점바인딩은 재귀적 호출을 가능하게 하기위해 함수템플릿 인스턴스화 선언 이후에 등장해야하며, 템플릿 정의에 쓰이는 한정되지 않은 이름은 지역 이름에 절대로 바인딩될 수 없다.
	템플릿 클래스나 클래스 멤버에 대해서는 인스턴스화 시점이 그것의 사용부분이 포함된 선언 바로 앞이어야 한다. name binding.cpp의 instaintiation_binding namespace의 3번째 예시를 참고하자. 의존성을 명시적으로 만들기 위해 템플릿 인자에 의존하는 것은 템플릿 코드에 대해 단순하게 생각할 수 있게 해주고, 심지어 지역 정보에까지 접근할 수 있게 해준다.
	템플릿 내에서 지역이름을 정의에 사용하지 않는 것이 모호성측면에서 좋지만, 그렇다고 해서 무리하게 std까지 따로 template argument로 정의할 필요는 없다. name binding.cpp의 ambigous namespace확인.
9.	특수화 생성 전략 3가지 '호출을 발견하는 최초 시점에 특수화생성', '해석단위의 끝에서 필요한 모든 특수화생성', '프로그램의 모든 해석 단위를 발견하고 필요한 모든 특수화생성'을 기반으로 템플릿 특수화는 '임의의 인스턴스화 시점', '해석단위내 인스턴스화 시점에 이어지는 임의의 시점', '특수화 생성을 위해 특별히 만들어진 해석 단위 안에서의 시점'에서 이루어진다.
	다만 인스턴스화시점을 다르게 했다고 의미가 달라져버리면 문제 있다. 고로 이러한 문제를 피하기 위해 템플릿에서 상황 의존성을 제한하려고 노력해야한다.
10.	템플릿도 Argument Dependent Lookup(ADL)이 적용되는데, 지나치게 공격적인 ADL은 얼추 맞는걸 찾으니 반환타입이 달라 오류를 내는 둥 좋지 않다. 이러한 경우 콘셉트를 이용하여 많은 문제를 해결할 수 있다. SFINAE 치환오류는 오버로딩우선순위상에서 제외.
	만약 함수 오버로딩에서 함수의 특정 버전이 고려되도록 보장하고 싶다면 using선언을 통해 현재의 scope에 추가할 수 있다. ex) using std::begin; using std::end;
11.	기반클래스가 템플릿 인자에 의존적이지 않으면 상관이 없는데 만약 의존적: public T이라면 조금 위험하다. 지역이름은 다른 범위의 이름을 가리기때문에 template argument가 들어오기 전에 다른 지역 혹은 전역 함수,객체등이 있다면 template argument를 신경쓰지 않고 바로 컴파일타임에 결정해버릴 수도 있다.
	이를 막기 위해선 의존성 명시를 해야하는데, 직접 ::을 사용하여 명시하거나, this->를 사용하여 전역함수가 call안되게 하거나, using T::~로 원하는 것을 유효범위로 가져오는 방법들이 있다.
	
	[템플릿과 계층 구조]
1.	polymorphism을 위해 template class나 Based class가 사용되며 가상함수를 통해 run-time polymorphism, 템플릿을 통해 compile-time(parametric) polymorphism을 제공한다. 템플릿(also called as type generator)은 특수화로, virtual은 인터페이스로 비슷한 polmorphism구현이 가능하지만 둘의 차이는 아래와 같다.
	인터페이스의 타입이 다르다(서로 다른 인터페이스를 이용하려면 casting이 필요), 매개변수와같이 일부 특수한 경우에만 클래스구현이 다르다, 인라인화가 필수일정도로 효율이 중요하다: 템플릿 / 실제타입이 컴파일타임에 알수없다, 계층구조가 필요하면 (템플릿특수화사이변환은 explicit casting이 필요하기에): 계층구조
2.	논리상으로 const set<cosnt Circle*>을 const set<const Shape*>로의 변환은 제공한다. 배열과 기반클래스의 조합은 컨테이너의 타입안전성을 제공하지 않는데, Circle[]에서 Circle*로 decay되고, Circle*이 Shape*로 변환되었을 때 C규칙 두가지, 배열이름은 첫원소포인터암시적변환, up-casting이 조합된다면 변환된 포인터를 기준으로 타입크기를 추정하여 다음 호출p[1]에 대해 실패할 것이다.
	고로 가급적 컨테이너를 선택해야하며 void f(T* p, int count)나 런타임 다형적이어야할 뭔가에 .이 있다면 의심해봐야 한다.
3.	동일한 클래스에서생성된 클래스들 사이에서 기본적이지 않은 관계를 위해 operator 형변환함수(애초에 그냥 이름있는 casting함수를 만들어...)를 정의한다면, enable_if를 제외하고 아래와 같은 방법이 있다. 다만 주의할 점은 템플릿 매개변수 리스트와 그것의 템플릿 멤버 중 하나는 서로 조합될 수 없다는 것이다. not use template<typename T, typename T2> on next example.
	template<typename T>
		template<typename T2>
			Ptr<T>::operator Ptr<T2>(){ return Ptr<T2>{p}; }//Ptr<T2>가 반환타입인 Ptr<T>로 반환되어야 작동. 즉, T2*가 T*에 대입될 수 있는 경우에 변환을 받아들이게 한다.
4.	template<typename T> class Vector<T*>: private Vector<void*> {}와 같은 구조는 타입 안전적인 인터페이스를 제공하는데 쓰일 수있으며, 구현 시 casting지역화에 유용하다.
5.	데이터 구조의 구성 예시로 레드블랙트리 구현을 생각해보자. data를 파생클래스에 넣고 가상함수를 이용하여 접근이 가능하지만 비용이 들며 캐스팅이 필요하다. void*를 노드에 넣고 바깥 데이터를 참조하게 하면 할당개수를2배로 늘리는 중 공간오버헤드가 증가되며 캐스팅이 필요하다(타입체크되지않는), 데이터를 노드에 넣을 수 있지만 비용과 불편함이 동시에 문제가 된다.
	해결로는 파생클래스 Node<Val>를 기반클래스 Node_base의 템플릿 인자로 전달하여 자신의 인터페이스Node_base에서 Node<Val>를 사용하게 하거나,