	[클래스]
1.	디버깅의 첫단계가 오류가 발생한 지점의 크기를 줄이기 위한 국소화인데, 클래스에서 모든 오류는 반드시 맴버 함수 내에서 일어나기에 localization이 이미 완성되어있게된다. 단순 데이터는 struct, 불변속성이 필요하면 class를 사용한다.(참고로 멤버 함수는 인라인 멤버 함수로 간주된다)
2.	비공개(private) 데이터는 주소조작(포인터에 산술연산), 명시적 타입 변환으로 뚫을 수 있다.
3.	class declaration은 정의가 아닌 선언이기에 #include로 다른 소소 파일에서 반복되어도 단일 정의 규칙을 위배하지 않는다.
4.	<클래스를 설계할때 프로그래머는 누군가에게 필요할 것 같다는 생각으로 추가하면 안되며, 정말로 신중하게 이 기능이 필요한지를 고려해야 좀 더 작도 좀 더 이해하기 쉬운 코드가 생성될 수 있다.>
5.	생성자에 explicit키워드를 이용하여 초기화나 명시적 변환 용도로 사용할 수 있다. (참고로 명시적 초기화를 direct initialization로 부른다. ex. my_fct(Date{15});)
6.	아래는 date_initializer인데, 단순히 struct를 정의하고 선언하는 것이며, 그 데이터를 사용할 뿐이라는 것에 유의하자
	struct{int d,m,y;} date_initializer={1,1,1970};
	class Date{ int d{date_initializer.d}; ...}
7.	우리 항상 햇갈리게 하는 주범은 mutable은 논리적 const에서 cache, cache_valid같은 실질적 non-const를 사용하기 위해 탄생했어요(소규모 객체 표현의 작은 부분에 적합. 복잡한 구조라면 lazy evaluation 형태 중 하나로 별도의 객체에 넣고 간접적 접근을 사용)
8.	member(nested) class는 자신이 소속된 클래스의 static멤버를 참조할 수 있는데, 포함된 클래스의 non-static에 접근하려면 포함된 클래스의 참조자로 가능하다.
9.	클래스의 보조함수는 직접적으로 접근할 필요가 없기에 대부분 클래스 자체 내에서 정의하지 않지만 그 연관관계를 명시하기 위해 클래스와 보조 함수들은 같은 네임스페이스에 포함시킨다. 또한 ADT역시 이용하려면 네임스페이스로 묶는 것은 좋은 선택이다.
10.	concrete type은 value type이라고도 불리우며 이것들을 사용하는 방식을 value-oriented programming이라고 부른다. 이들은 polymorphism을 표시하기엔 적합하지 않다. 이들의 크기는 컴파일 타임에 알려지며 연산의 인라인화도 달성된다.

	[생성, 마무리, 복사와 이동]
1.	생성자에서 불변속성 구축에 실패한다면, 아무런 객체가 생성되지 않으면서도 memory leak이 없도록 보장해야한다. 명시적 소멸자 호출은 RAII덕분에 불필요하다. 고로 소멸자를 private로 선언하는 것이 좋다.(=delete보다) 만약 명시적인 소멸이 가능하다면 함수를 제작하자(like factory function)
2.	virtual 기반클래스는 기반 클래스 중 가장 먼저 생성되며 모두 소멸된 후에 소멸된다. 이러한 규칙을 위해 Derived 클래스의 생성자&소멸자 순서가 존재한다. (ex. Based에는 A->B생성, Derived에선 B->A생성. Destructor에서는 A->B? B->A?)
3.	new(p) X{a};//주소 p에 있는 a값으로 X를 복사생성한다 라는 의미로 '위치 지정 new'라고 부른다.
4.	struct X{ X(int); };//생성자에서 int하나 요구. 
	X x4{1,2};//오류_잘못된 초기화 식 개수 X x5{x4};//복사는 가능하다. 즉. 생성자가 요구하는 적절한 초기화 식 없이 객체를 생성하는 것은 잘못된 것이지만 객체는 복사될 수 있다는 가정 때문에 copy constructor로 뚫을 수 있다.
5.	default constructor을 사용할지 말지에 대한 설명은 '기본값을 갖는 것이 타당한지', '기본값으로 사용할 수 있는 특별한 값을 갖고있는가'를 스스로 물어봐야 한다. <중요한 것은 default constructor을 사용한다는 것은 default initialization을 허용한다는 것이다.>
6.	생성자 선택에 대해서는 기본생성자->초기화식 리스트->etc 순으로 우선권을 갖는다. initializer_list<T>는 ㄹㅇ 리스트로 값으로 전달되며(복사. 고로 변경불가) begin(), end(), size()등으로 시퀸스로서 인자접근이 가능하다.
7.	initializer_list를 사용하여 constructor arguments를 초기화하는 경우에 해당 순서대로 초기화되는 것이 아닌, 정의된 순서대로 초기화된다. 아래는 예시이다.
	class B1{ B1(); }	class B2{ B2(int); }	struct D1: B1,B2{ D1(int i):B1{}, B2{i}{} };	struct D1:B1, B2{ D1(int i){} };//여기에서 D1의 생성자를 따라 B2가 i로 초기화 될 것 같지만, initializer_list에서 정의된 순서로 들어가기에 int i가 B1로 들어가서 B2에서 int인자가 없다는 오류를 출력한다.
8.	Derived생성자를 통해 기반클래스의 기반클래스를 초기화하거나 기반 클래스의 멤버를 초기화할 수는 없다.
9.	delegate constructor(forwarding function)은 기존의 생성자를 다른 생성자(오버로딩이라던가)에서 이용하는 것을 의미한다. 또한 두개의 생성자가 똑같은 동작을 수행하게 하고 싶다면 private로 init()함수를 만들어 사용하면 된다.
10.	X(int x){ if(0<x && x<=max) a=x; else throw Bad_X(x); }
	X() { X{42}; }//ㅋㅋㅋ 디버깅 해봐아 오류가능성 있는데 ㄹㅇ 이러면 못찾을거같네 초기화식이 initialzer_list이용이 아니라 body에 있음ㅋㅋㅋ
11.	생성자의 initializer_list사용 없이 클래스 선언 안에서 바로 non-static 데이터 멤버에 대한 초기화 식을 지정할 수 있는데(int a=3;)이는 다중 생성자를 가진 클래스에서 위력을 발휘한다.
12.	static 멤버의 선언은 static, 초기화는 const static을 사용한다. static은 constexpr이어야 한다.
13.	이동은 유효하지 않은 객체를 소멸시킬 수 없기에 예외를 던질 수 없는 반면, 복사는 던질 수 있다. operator=오버로딩에서 복사 예외를 막고싶다면 사본을 만든 후 swap을 하는 방법이 유익하다. 대입을 이동으로 보는 것도 유용하다.
14.	복사는 equivalence(x=y후 x와 y과 동일한 결과 산출_위반 예시 복사손실: slicing, casting), independence(x연산은 y상태변경 X_포인터 복사시 유의. 별도의 operation필요)를 만족해야한다. 
	slicing을 막기 위해 기반클래스의 copy constructor을 delete하고 clone()을 제공하고 기반클래스를 private&protected로 만든다. 복사대입은 자가대입에도 안전해야한다.
15.	rep=shared_ptr<Representation>{clone()};로 복사생성자 시 인자를 보호할 수 있으며, 불변하는 공유상태 ptr에서는 copy_on_wirte디자인을 고려할 수 있다. 
16.	이동연산을 사용할 수 없다면 Matric& res=*new Matrix; ... return res로 아예 반환을 자유저장공간을 가리키는 reference로 해버리는 편법도 있다. p.572
17.	모든 클래스에게 던져야하는 기본 질문들이다. default constructor가 필요한가? destructor이 필요한가? 복사&이동 연산이 필요한가?
18. delete를 이용하여 함수 템플릿의 특수화 집합에서 특수화를 삭제할 수 있다. template<typename T> T* clone(T* p){ return new T{*p}; }; 	Foo* clone(Foo*)=delete; 아래는 또다른 delete의 사용이다.
	class Not_on_stack{ ~Not_on_stack()=delete; }//소멸될 수 없는 지역 변수는 가질 수 없다.
	class Not_onf_free_store{ void* operatoe new(size_t)=delete; }//new 금지
	void f(){
		Not_on_stack v1;//ERROR cannot remove
		Not_on_free_store v2;//OK just declaration
		
		Not_on_stack* p1=new Not_on_stack;//OK nullptr
		Not_on_free_store* p2=new Not_on_free_store;//ERROR cannot allocate
	}
	
	[연산자 오버로딩]
1.	operator T()는 타입 T로의 변환을 정의한다. literal은 operator""@로 표기하여 정의한다(auto x{3.4i}). enum역시 (사용자 정의 타입이기에)operator을 정의할 수 있다. 연산자 오버로딩 예시_std::cout.operator(p), operator<<(std::cout, s)
2.	x@y에서는 operator&을 x,y순으로 찾고 없으면 x,y의 네임스페이스 순으로 operatoe@의 선언을 찾는다.
3.	complex의 2+z같은 연산을 처리하기위해(자바에서 auto-boxing느낌) mixed-mode arithmetic이 필요한데, complex& operator+=(complex a){}		complex& operatoe+=(double a){}처럼 여러 적절한 버전만 추가하면 된다. 하지만 대부분 complex처럼 타입변환후 사용하기에 인자에 complex만 두어 호출시 생성자가 호출되게 하자.
	complex b{3}처럼 scalar을 받아들이기 위해선 단일인자생성자를 제공하면 된다. 원치않을 경우엔 explicit로 선언하자.
4.	리터럴 오버로딩은 다음과 같다. constexpr complex<double> operator""i(long double d){ return {0, d}; }