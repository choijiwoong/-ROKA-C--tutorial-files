	[런타임 타입 정보]
1.	런타임타입조사(Run-Time Type Information(RTTI)) 연산은 casting이며, 유효한포인터나 nullptr(혹은 throw)을 반환한다(즉, dynamic_cast<T*>(p)는 p가 가리키는 객체가 존재한다면 T타입인가?와 동일. dynamic_cast<T&>(r)은 <T*>와 달리 질문이 아닌 단정이다. dynamic_cast는 다르게 말하면 인터페이스를 제공하는지 묻는 메커니즘이다.)
2.	dynamic_cast는 포인터나 참조자가 다형적 타입이어야 downcast나 crosscast를 할 수 있다(객체탐색에 필요한 정보가 비다형적객체에는 없기에). 다만 단점은 정확한 타입을 모를 경우 안전한 조작이 불가능하다는 것이다. void*로의 dynamic_cast는 오로지 다형적 타입 객체의 시작 주소를 판변하는데에 사용된다(void*->other type dynamic cast 불가능. static_cast로 진행_프로그래머를 믿고)
3.	class lattice의 탐색은 cross cast에서도 이루어지는데, 일반적으로 virtual상속이 아니어서 복사상속된 기반클래스를 가리키는 포인터의 모호성은 컴파일타임에 탐지되지 않는다. virtual일경우 컴파일타임에 탐지된다.
4.	dynamic_cast와 static_cast는 모두 const와 access modifier를 침해하지 않기에 static_cast나 reinterpret_cast로 private기반 클래스를 캐스팅하는것은 가능하지 않므며, const_cast로 const를 없앤다하더라도 객체 내부에 멤버가 const면 해당 내용은 여전히 사용이 불가하다.
5.	기반 클래스의 종류를 정확히 알기위해 typeid()를 사용하는데, 일반적으로 연결된 데이터 구조를 송신하고 여러 개의 포인터가 가리키는 객체의 중복을 피하기 위해서는 (pointerm, id)쌍의 테이블까지 보관한다.
6.	Dynamic Dispatch는 두 가상함수중 선택하는 것이며, Double Dispatch는 두 타입을 기반으로 가상함수를 선택하는 방법, Visitor는 이중 디스패치를 이용하여 계층 구조에 단 하나의 가상함수만 추가하면서 여러개의 함수를 클래스 계층 구조에 추가하는 방법이 있다.
	intersect상황에서 double dispatch를 이용하면 intersect여부에 관계없이 s1에 적합한 가상함수를 호출하고, s2에 적합한 함수를 호출하는 것이다. 해결은 모든 조합을 다 함수로 만들거나, bounding box로 하나의 function으로 처리하며 intersect를 ck하거나, search_table을 미리 정의할 수 있다.
	intersect상황에서 visitor을 이용하여 균일한 데이터 구조(일반화)에 의한 명시적 반복 수행을 기반으로, 다양한 타입의 다중 노드에 대한 접근을 필요로 하는 연산을 주로 간단히 구현할 수 있다.
	(p.s 객체의 행위를 외부로빼서 객체의 행위를 위임하는 패턴으로 전략패턴(1:N), 커맨드 패턴(1:1), 비지터 패턴(N:N)이 있다.)
7.	생성이나 소멸 도중에 virtual함수를 호출하게 된다면 지금까지 생성된 것만이 동적타입이 반영되기 때문에 한참 Based의 기반 클래스만 생성되었다고 가정하고 virtual을 call할 수 있다. 고로 생성&소멸중엔 virtual함수를 호출하지 말아야 한다.
8.	<typeinfo>의 typeid()에 피연산자로 완전히 정의된 타입의 이름이 주어지면 해당 type_info에 대한 reference를 반환한다. 또한 피연산자로 expression이 주어질경우 expr의 type_info reference를 반환한다. expr이 nullptr이라면 std::bas_typeif exception을 throw한다.
	voif f(Shape& r, Shape* p){ typeid(r);//r로 참조되는 객체의 타입		typeid(*p);//p가 가리키는 객체의 타입		typeid(p);//포인터의 타입(Shape*)_주로 이런경우는 실수. 객체가 아닌 포인터 타입. }
9.	type_info도 다형적이기에 포인터로 접근하면 안되고 오로지 값으로만 접근해야 한다. type_index는 type_info객체를 비교하고 해싱하기 위한 표준 라이브러리 타입이다. 시스템헤더 수정없이 typeid를 정보와 연결시키면 서로 다른 정보를 서로 독립적으로 타입과 연결시킬 수 있어 모든 사용자를 만족시킬 수 있는 단일정보집합을 제공한다.
10.	당연하겠지만 RTTI는 필요할 때만 사용되야한다. 대부분 virtual로 대체할 수 있으며, 가급적 typeid나 dynamic_cast에 기반을 둔 반복되는 switch문보다는 virtual function을 사용해야한다. 불필요한 오버헤드를 줄이며, 대체 가능하다.

	[템플릿]_template<typename T> class D: public B<T>{}
1.	단일 기계 명령인 템플릿(혹은 [])이 간단한 인라인화와 결합된다면 최적화에 좋다. 또한 클래스 템플릿 이름을 오버로딩 하는 것은 불가능하다. 즉, non-template function과 template function의 이름이 같다면 중복정의오류이다.(p.s using별칭은 associated type이라고도 불린다)
2.	C++은 템플릿 인자에 대한 요구사항을 직접 표현할 수 없기에(와일드카드 in JAVA) 프레임워크과 요구사항을 논의하기 위해 용어 체계를 구축하는데, 그러한 요구사항의 집합을 술어함수로 해석하며 설계도구로서 콘셉트(concept)라고 부른다. 다만 낮은 수준의 추상화를 느리게 수행한다.
3.	템플릿 인자에 연관된 오류가 가장 빨리 탐지될 수 있는 시기는 point of instatiation이다. 다만 일부구현은 링크될때까지 체크를 연기하므로 완전한 체크가 가능한 시점은 링크타임이다.(p.s 생각해보면 당연한게, non-static멤버는 constexpr이 될 수 없다._instantiation으로 생성되기에..)
4.	중첩된 타입이 정말로 모든 템플릿 매개변수에 의존하고 있지 않다면 템플릿에서 nested type은 피해야 한다(외부로 분리). 멤버로 해두면 매개변수 의존성도 생각해야하며 불필요한 코드로 인해 일부 코드가 불어날 수 있기 때문이다.
5.	friend관계는 상속되지도 않고, 추이적(transtive)이지도 않다. 참고로 Link<X>가 오직 List<X>의 프렌드여야 한다라고 기술할 수 있는 방법은 존재하지 않는다.
6.	클래스 템플릿의 매개변수처럼 추론되지 않는 것들은 템플릿 매개변수를 명시적으로 지정해야한다. template<typename T> T* create(); 		int* q=create();//ERROR
7.	좌변값과 우변값에 대해 서로 다른 동작을 취하는 것이 유용한데, 다음과 같은 테크닉이 가능하다. template<typename T> class Xref{ 	Xref(int i, T& r): index{i}, elem{{&r}, owned{false}{}	Xref(int, T&& r): index{i}, elem{new T{move(r)}}, owned{true}{}		}//copy rvalue and make new object by lvalue
8.	함수템플릿 오버로딩규칙은 다음과 같다. 템플릿 특수화의 집합을 먼저 찾는다(tmp우선)->그 중 가장 특수화된 템플릿함수를 고른다->통상적인 함수의 오버로딩 규칙을 적용한다(ADL에 의한다면 변환적용X).->함수의 특수화과 일반 함수와 같다면 일반 함수가 선택된다->모호 오류 발생
	다만 통상적인 함수의 오버로딩 규칙 적용단계에 이르게 되면 템플릿 매개변수가 고유하게 결정되기 전까지는 타입 승격과 표준 변환을 적용하지 않는다는 문제가 있다. 고로 명시적한정<type>으로 해결(유지보수Good)하거나 inline int max(int i, int j){ return max<int>(i,j); }처럼 inline타입변환 함수를 만들어 오버로딩 시켜해결할 수 있다.
9.	인자대체실패는 SFINAE에 의하여 우회가 가능하다. template<typename Iter> typename Iter::value_type mean(Iter first, Iter last);	template<typename Iter> T mean(T*, T*);//앞의 함수에 포인터 넣을시 다음 함수에 의해 정상적인 작동 가능.(SFINAE는 컴파일이 실패해도 최적의 일치 함수를 선택할 수 있게해준다)
10.	inline이 아닌 non-template function들과 static멤버들은 일부 컴파일 단위에서 고유 정의를 가져야하는데, 많은 해석 단위에 포함될 가능성이 있는 템플릿은 쓰지 않는 것이 좋다는 것이다. 많약 쓰게 되면 구현에서 잡아낼 수없는 오류가 발생될 수 있다. 만약 불가피하다면 명시적 인스턴스화나 extern template(한번만 인스턴스화되게)을 사용하자.
11.	최적의 방법은 복잡한 템플릿 라이브러리를 비템플릿 인터페이스로 캡슐화하여 라이브러리 변경의 노출을 최소화하는 것이다. ex. double accum(const vector<double>& v); 템플릿이 없는 선언! 알아서 내부에서 추론한다. 다만 복잡성의 근원이 될 수 있기에 표준라이브러리 구현에는 사용하지 않는것을권장하지만, 더 복잡하며 자주 변경된다면 유용하다.
12. 클래스 템플릿을 복사가능하게하려면 비템플릿 복사 생성자와 비템플릿 복사 대입 생성자를 만들어야 한다. 또한 템플릿 설계시 템플릿 인자에 대해 가정된 콘셉트(tmp인자 요구사항)를 신중하게 고려해야 한다.