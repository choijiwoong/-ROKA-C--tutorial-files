	[런타임 타입 정보]
1.	런타임타입조사(Run-Time Type Information(RTTI)) 연산은 casting이며, 유효한포인터나 nullptr(혹은 throw)을 반환한다(즉, dynamic_cast<T*>(p)는 p가 가리키는 객체가 존재한다면 T타입인가?와 동일. dynamic_cast<T&>(r)은 <T*>와 달리 질문이 아닌 단정이다. dynamic_cast는 다르게 말하면 인터페이스를 제공하는지 묻는 메커니즘이다.)
2.	dynamic_cast는 포인터나 참조자가 다형적 타입이어야 downcast나 crosscast를 할 수 있다(객체탐색에 필요한 정보가 비다형적객체에는 없기에). 다만 단점은 정확한 타입을 모를 경우 안전한 조작이 불가능하다는 것이다. void*로의 dynamic_cast는 오로지 다형적 타입 객체의 시작 주소를 판변하는데에 사용된다(void*->other type dynamic cast 불가능. static_cast로 진행_프로그래머를 믿고)
3.	class lattice의 탐색은 cross cast에서도 이루어지는데, 일반적으로 virtual상속이 아니어서 복사상속된 기반클래스를 가리키는 포인터의 모호성은 컴파일타임에 탐지되지 않는다. virtual일경우 컴파일타임에 탐지된다.
4.	dynamic_cast와 static_cast는 모두 const와 access modifier를 침해하지 않기에 static_cast나 reinterpret_cast로 private기반 클래스를 캐스팅하는것은 가능하지 않므며, const_cast로 const를 없앤다하더라도 객체 내부에 멤버가 const면 해당 내용은 여전히 사용이 불가하다.
5.	기반 클래스의 종류를 정확히 알기위해 typeid()를 사용하는데, 일반적으로 연결된 데이터 구조를 송신하고 여러 개의 포인터가 가리키는 객체의 중복을 피하기 위해서는 (pointerm, id)쌍의 테이블까지 보관한다.
6.	Dynamic Dispatch는 두 가상함수중 선택하는 것이며, Double Dispatch는 두 타입을 기반으로 가상함수를 선택하는 방법, Visitor는 이중 디스패치를 이용하여 계층 구조에 단 하나의 가상함수만 추가하면서 여러개의 함수를 클래스 계층 구조에 추가하는 방법이 있다.
	intersect상황에서 double dispatch를 이용하면 intersect여부에 관계없이 s1에 적합한 가상함수를 호출하고, s2에 적합한 함수를 호출하는 것이다. 해결은 모든 조합을 다 함수로 만들거나, bounding box로 하나의 function으로 처리하며 intersect를 ck하거나, search_table을 미리 정의할 수 있다.
	intersect상황에서 visitor을 이용하여 균일한 데이터 구조(일반화)에 의한 명시적 반복 수행을 기반으로, 다양한 타입의 다중 노드에 대한 접근을 필요로 하는 연산을 주로 간단히 구현할 수 있다.
	(p.s 객체의 행위를 외부로빼서 객체의 행위를 위임하는 패턴으로 전략패턴(1:N), 커맨드 패턴(1:1), 비지터 패턴(N:N)이 있다.)
7.	생성이나 소멸 도중에 virtual함수를 호출하게 된다면 지금까지 생성된 것만이 동적타입이 반영되기 때문에 한참 Based의 기반 클래스만 생성되었다고 가정하고 virtual을 call할 수 있다. 고로 생성&소멸중엔 virtual함수를 호출하지 말아야 한다.
8.	<typeinfo>의 typeid()에 피연산자로 완전히 정의된 타입의 이름이 주어지면 해당 type_info에 대한 reference를 반환한다. 또한 피연산자로 expression이 주어질경우 expr의 type_info reference를 반환한다. expr이 nullptr이라면 std::bas_typeif exception을 throw한다.
	voif f(Shape& r, Shape* p){ typeid(r);//r로 참조되는 객체의 타입		typeid(*p);//p가 가리키는 객체의 타입		typeid(p);//포인터의 타입(Shape*)_주로 이런경우는 실수. 객체가 아닌 포인터 타입. }
9.	type_info도 다형적이기에 포인터로 접근하면 안되고 오로지 값으로만 접근해야 한다. type_index는 type_info객체를 비교하고 해싱하기 위한 표준 라이브러리 타입이다. 시스템헤더 수정없이 typeid를 정보와 연결시키면 서로 다른 정보를 서로 독립적으로 타입과 연결시킬 수 있어 모든 사용자를 만족시킬 수 있는 단일정보집합을 제공한다.
10.	당연하겠지만 RTTI는 필요할 때만 사용되야한다. 대부분 virtual로 대체할 수 있으며, 가급적 typeid나 dynamic_cast에 기반을 둔 반복되는 switch문보다는 virtual function을 사용해야한다. 불필요한 오버헤드를 줄이며, 대체 가능하다.

	[템플릿]
