	[스레드와 태스크]
5.	thread_local 변수는 thread가 소유하는 개체를 가리키며 extern일 수 있다. 이 공간은 전역변수의 논리적 문제를 공유하며, thread storage duration을 가진다고 일컫는다. 데이터 경합의 문제를 thread_local을 이용하여 해결할 수 있지만 조심해야하며 default_value는 0이다.
6.	데이터 경합 방지를 위해선 공유하지 않거나 무잠금을 이용하거나 mutex(recursive_(반복획득가능), timed_(기다렸다가 lock_ex. 이미지 로딩), lock_guard<M>(연산지원X), unique_lock<M>(연산지원O)), condition variable(thread간 통신)을 이용한다. 표준 mutex는 exclusive ownership sementic을 제공한다.
7.	mutex 조작시 오류 조건으로는 resource_deadlock_would_occur, resource_unavailable_try_again(핸들일부이용불가능), operation_not_permitted, device_or_resource_busy(이미lock), invalid_argument가 있다.
8.	try_lock이 모든 잠금을 획득했다면 -1을 반환하고 실패시 불가능한 잠금의 개수를 반환한다. call_once(f1, f, args)함수(f1이 아직 사용X면 f(args)호출)는 경합조건에 빠지지 않게 객체를 초기화하는데에 사용되며(여러스레드가 call해도 한번만 call), 초기화된 static데이터를 사용하면 preconcurrency코드를 수정하는 방법이다.
9.	condition_variable에 사용되는 wait(lck)는 가짜로 깨어나기의 가능성이 있는 저수준 연산이다. 고로 wait_for등을 이용한 기다림이 보다 좋다. 이를 이용하여 Sync_queue를 만들 수 있지만, 유의해야하는 것은 get()와 put()만 보호되기에 자체로는 공유 데이터 구조가 아니다. 잠금 가능한 임의의 객체가 될 수 있는 condition_variable_any또한 있다.

10.	태스크 기반의 병행성을 요약하기 앞서 가장 단순한 기법을 사용하는 것이 최선이며, 정말 가치가 있을 경우 복잡한 해결책을 사용하는 것을 확신할때 사용해야한다. packaged_task<F>, promise<T>, future<T> shared_future<T>, async(policy, f, args), async(f, args) 를 지원한다.
11.	future-promise에 사용되는 값은 shared state라고 불리며, 공유상태는 최소한 적절한 타입, 예외의 값, void반환 future, deffered 런칭 정책으로 async()에 의해 실행될 태스크, use count, mutual exclusion data등을 보관할 수 있어야 하며 구현은 Construct, Make ready, Release, Abandon를 할 수 있어야한다.
	promise에 대해선 swap은 가능하나 복사연산이 존재하지 않으며 하나의 결과 값 전송이 가능하고, 이미 설정됀 상태에서 set호출시 future_error을 던진다. 
12.	packaged_task는 상당한 연산 집합(valid(), swap(), reset(), uses_allocator<PT,A>, make_ready_at_exit()_thread_local변수에 대한 소멸자 실행 전까지 결과 이용 불가)을 제공한다. 마찬가지로 이동가능(새 thread의 스택으로도 가능하단 얘기)하나 복사불가하다. 공유 상태를 버린다는 것(이동)은 그것을 준비시킨다는 뜻이다.
	정말 간단한 예제에 대해서는 thread를 전혀 사용하지 않고 task처리(통상적인 함수 호출 버전과 동일하게)가 가능하다. future은 공유 상태에 대한 핸들로 share()_이동, wait()_봉쇄, wait_until(tp)등을 지원한다. future은 get()을 딱 한번만 호출가능(두번시도시 미정의행동. 권장은 future_error)하기에 여러번 읽어야 한다면 shared_future을 사용할 수 있다.
13.	future의 상태(ready, timeout, deffered)는 wait_for(), wait_until()을 호출하여 관찰 가능하며, 가능한 오류는 broken_promise(값 제공 전 상태를 버림), future_already_retrieved(두번 get), promise_already_satisfied(두번 set), no_state(연산생성전 promise공유상태 접근시도)이다. wait_for_all(args), wail_for_any(args)함수도 존재한다.
14.	shared_future은 복사대입이 가능하다. future와의 차이는 shared_future는 반복적으로 읽혀지고 공유될 수 있는 위치로 자신의 값을 이동시킨다는 것이다. 반환된 객체가 참조자가 아니라면 const이므로 동기화 없이 여러개의 thread에 의해 안전한 접근이 가능하다.
15.	future, promise, packaged_task에서 더 저수준으로 얼만큼의 thread를 사용할지, 어느 thread에서 실행할지 에 대해서 보통 thread launcher에 위임될 수 있는데, 이는 새로운 thread를 생성할지, 오래된 thread를 재사용(in thread pool)할지, 현재의 스레드에서 task실행할지를 결정하는 함수로 비동기적 태스크 런처로 future<Return_type>을 반환하는 sync(policy, f, args)가 있다.
16.	async()호출자는 thread에 관한 다양한 정보를 제공할 수 있으며, 표준에는 async(새 thread가 task수행을 위해 생성된 것 처럼 태스크를 수행한다)와 deffered(task의 future에 대한 get()실행 시점에 task를 수행한다) 런칭정책만을 포함한다. 
17.	개별적인 태스크는 표준라이브러리 find_if를 사용하며, 병렬처리시 grain과 Record개수에 의해 요구되는 만큼 async를 호출하는 pfind를 사용할 수 있다. 병행적 실행의 세부 사항이 완전히 은닉되도록 프레임워크의 틀에서 개발될 때 map-reduce라고 한다. 
18.	만약 상당한 병렬적인 속도 개선이 필요하다면 packaged_task, Sync_queue에 맞춰 미리 계산된 thread집합과 작업 큐를 기반으로 자체만의 async()를 변형해야 한다.

	[C 표준 라이브러리]
1.	C의 printf는 타입 체크가 이루어지지 않기에 segmentation fault혹은 최악의 결과를 낳을 수 있다. C의 표준 출력 stdout은 cout에 대응되고 stdin은 cin에 대응되며, stderr은 cerr에 대응된다. 이 대응관계는 너무 밀접하기에 C 스타일 입출력과 입출력 스트림은 버퍼를 공유할 수 있다. 즉, cout와 stdout연산이 섞인 조합이 하나의 출력 스트림을 만들 수 이쑈다.
	더 나은 성능을 위해선 하나의 스트림에 대해 stdio와 iostream연산을 섞지 않으며, 첫번째 입출력 연산 전에 ios_base::sync_with_stdio(false)를 호출하면 된다. 
2.	C의 scanf는 모든 인자를 포인터로 받기에 오류에 취약하며 gets()가 안정성면에서 더좋다. stdio함수중에 gets()외에도 ungetc(입력스트림에 다시 돌려놓기_두번연속 사용 금지)같은 여러 함수가 있다.
3.	메모리 조작 함수는 void*를 통해 원시 메모리에 적용되며, C스타일 메모리 연산으로 memcpy, memmove, memcmp, memchr, memset, calloc, malloc, realloc, free가 있다. realloc을 cast랑 같이 했을때 발생하는 double allocation이유를 모르겠네.. cpp 참고 무튼 원시 메모리에만 사용해유.. not void..
4.	<cstdlib>에서 abort(), exit(n), system(s), qsort(b,n,s,cmp), bsearch(k,b,n,s,cmp), rand(), srand()등의 기타 함수들도 있다.
5.	<csetjmp>의 longjmp()는 비지역적인 goto로서 일치하는 setjmp()의 결과를 찾을 때 까지 스택을 뒤집어 놓는데, throw에 의해 소명자가 호출될경우 미정의동작을 하므로 C++에선 set_jmp()를 절대 사용하면 안된다.

	[호환성]
1.	deprecated인 기능은 소멸자를 가진 클래스의 복사 생성자와 복사 대입 생성, 리터럴 char*대입, unexpected~는 noexcept로 대체, auto_ptr등이 있다.
2.	C++에서는 struct이름이 그것이 선언된 유효범위에 들어가지만, C에서는 안쪽 유효범위에서 선언된 C++ struct이름은 바깥쪽 유효 범위의 이름을 가릴 수 있다. 알아듣게 말하면 C++이 직관적으로 struct이름을 읽고, C의 경우 struct이름은 다른 이름에 가려질 수 있다.
3.	C에서는 대부분 함수가 미리 선언되지 않고 호출될 수 있으며, 아무 인자 타입도 지정하지 않고 선언된 함수가 임의의 타입을 인자를 임의의 개수만큼 받아들일 수 있다. C에서는 인자리스트 다음에 선택적으로 인자를 지정하는 문법을 사용할 수 있다. ex) void f(a,p,c) char *p; char c; {/*...*/}. C는 struct가 반환 타입과 인자 타입선언으로 정의가 가능하다.
	C는 extern없이도 단일 해석 단위에서 여러번 선언될 수 있으며, 하나라도 초기화 식을 제공하면 해당 객체는 한번 정의된 것으로 간주한다. C에서는 문자열리터럴이 char배열이지만 C++은 const char배열이다. C의 전역 const는 기본 설정으로 외부 링크 관계를 가진다.
	C에서 중첩된 struct이름은 그것이 있는 구조체와 동일한 유효 범위 내에 위치한다. C는 배열이 요구하는 것보다 더 많은 원소를 가진 초기화 식에의해 포기화될 수 있다.
4.	C++의 함수 링크는 타입안전하지만, C는 타입안전성을 요구하지 않아 C++함수가 C++로 컴파일되면서 동시에 C호출규약을 준수하려면 extern "C"로 선언해야한다.