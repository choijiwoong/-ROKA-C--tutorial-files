	[STL 알고리즘]
1.	반복자 기반의 인터페이스는 시퀸스 개념은ㄹ 직접적으로 표현하지 않아 일부 범위 오류를 탐지 하는데 어려움을 겪을 가능성이 있다. 또한 표준 라이브러리 알고리즘은 설계시 STL의 이동의미구조에 대한 지원이 없었기에 반복자를 반환하는데, 이는 새 container를 반환하여 해결이 가능하다(by ex. vactor<Value_type<Cont>*>)
2.	지정되지 않는 한 알고리즘에 전달되는 정책인자(Predicate)는 원소를 변경하지 않아야 하며 사용이 필요하다면 const를 붙여 보호해야한다(or for_each이용.). 또한 predicate는 연산의 의미를 변경하는 상태를 보유하지 않아야 한다.(포인터 원소에 대한 ==와 <은 STL에 거의모두 옮지 않다)
3.	sequence predicate로는 all_of(b,e,f), any_of(b,e,f), none_of(b,e,f)가 있는데 실패 시 어느 원소가 실패했는지는 알 수 없다. count(b,e,v)도 predicate를 이용하는 count_if(b,e,f)로 사용이 가능하다.
	equal(), mismatch(), search(), search_n(), transform()_입력 항상 바꾸진 않음, copy()_back_inserter(v)처럼 삽입자 사용 가능, copy_if(), move_backward(), unique()_중복원소없이 이동 but 컨테이너 종류 모르기에 우리가 기대하는 방식이 아닐 수도 있기에 명시적으로 erase사용하는 컨테이너로 변경해야함, unique_copy(),
	remove()_몇몇 algorithm들은 input sequence의 size변경이 불가하기에 크기가 변경 안될 수도 있음+원소를 뒤끝으로 이동시켜 제거, reverse(), replace(), rotate()_by using swap, random_shuffle()_by using uniform distribution random generator, partition(), partition_point(), is_partitioned(),
	next_permutation(), is_permutation()_sort on dictionary, fill(), generate()_fill이랑 유사한데 f를 하나 더 받아 f()반환값을 assign함, iter_swap _iterator가 가리키는 원소를 swap, stable_sort(), is_sorted_until(), nth_element(b,n,e)_n은 정렬해도 현재위치
4.	표준 list는 Random Access Iterator가 없기에 필요시 vector로 복사해서 다시 list로 옮겨야 한다. 또한 STL 알고리즘은 ==가 아니라 동등성 비교인 !(a<b)&&!(a>b)  == !((a<b)||(a>b))을 사용한다는 것을 유의하자.
5.	binary_search(), equal_range(), lower_bound(), upper_bound()와 같은 이진검색계열 알고리즘은 bidirectional iterator없이 forward-iterator만으로 구현이 가능하다.
6.	merge()_out따로 존재, inplace_merge()_레알 병합, 집합알고리즘: includes(), set_union(), set_intersection(), set_difference(), set_symmetric_difference()
7.	Heap은 가장 높은 값을 맨 앞에 놓는 간결한 데이터 구조이다. make_heap(), push_heap(), pop_heap(), sort_heap(), is_heap(), is_heap_until()
8.	lexicographical_compare()는 사전에서 순서를 정렬할 때 쓰이는 규칙, min과 max계열: pair(x,y)=minmax(a,b)

	[STL 반복자]
1.	반복자의 카테고리로는 input iterator, output iterator, forward iterator, bidirectional iterator, random-access iterator로 크게 5가지가 있다. 이들은 클래스가 아닌 concept이므로 class hierarchy가 아니다.
2.	<iterator>의 반복자 특성 정보 iterator_traits<>, input_iterator_tag, output_iterator_tag, forward_iterator_tag, bidirectional_iterator_tag, random_access_iterator_tag를 사용할 수 있다. 이들을 사용하는 코드들은 tag dispatch기법으로 inline화 될 것이다.
	반복자를 인자로 받는 코드에 typename iterator_traits<Iter>::value_type 혹은 ::reference_type처럼 iterator_traits를 사용하여 구현하며 pointer 입력 시에도 정상적으로 거를 수 있다. 
	이를 이용하여 두 반복자 사이의 차이에 대한 타입을 알고 싶을 때 (실제로는 별칭사용) typename std::iteator_traits<Iter>::difference_type<Iter> d4=distance(p,q) 혹은 auto d5=distance(p,q)를 사용하면 된다.
3.	유용한 반복자 타입을 생성할 수 있는 iterator adaptor로는 reverse_iterator, back_insert_iterator, front_insert_iterator, insert_iterator, move_iterator, raw_storage_iterator가 있다.
4.	삽입 반복자로는 insert_iterator, front_isert_iterator, back_insert_iterator가 있으며 각각 insert(), push_front(), push_back()을 사용하여 삽입한다. 이들은 다음과 같은 삽입자 생성 함수를 통해 생성된다. inserter(), back_inserter(), front_inserter() 이들은 컨테이너의 반복자여야 한다.
5.	이동 삽입자(복사가 아닌 이동)은 이동 반복자 생성 함수 make_move_iterator을 이용하여 만들어진다. ex. copy(make_move_iterator(vs2.begin()), make_move_iterator(vs.end()), back_inserter(vs3));
6.	<iterator> 표준 라이브러리에서 웬만한 것들은 다 받을 수 있는 begin()과 end()를 제공한다. 이들은 자동적으로 begin()과 end()를 가진 사용자 정의 컨테이너에 획득되기에 직접 커스텀 한 멤버 버전을 사용하고싶으면 template<typename T> Iterator<My_container<T>> begin(My_container<T>& c) { return Iterator<My_container<T>>{&c[0]; }; }과 같이 오버로딩해야한다.
7.	<functional>에서 주로 사용되는 predicate들을 제공한다. 산술연산도 마찬가지이다. functional adaptor는 함수인자를 받아들이고 원래 함수를 실행시키는 함수 객체를 반환한다. bind(f, args), mem_fn(f), not1(f), not2(f)등이 있다. bind와 mem_fn은 Currying이나 partial evaluation라고 불리는 argument binding을 수행한다.
	오버로딩된 함수에 대한 인자를 바인딩하려면 double(*)(double,double)pow처럼 정확히 어떤 버전의 함수를 bind하려는지를 명시적으로 기술해야하며, 유의해야하는 점은 bind에 참조자를 쓸 경우에 참조자를 접하기 전에 참조자가 역참조되기에 지역사본을 다룰 수 있다. 이를 해결하기 위해선 reference_wrapper인 ref()를 사용하여 해당 bind function을 사용하면 된다.(일찍 참조자를 역참조한다. 미루기 위해 ref사용한다.)
8.	mem_fn은 비멤버 함수로 호출될 수 있는 functor을 만들어낸다. 즉 멤버를 비맴버객체로 변환할 수 있다. 이는 객체지향적인 호출 스타일에서 함수형 스타일로의 매핑으로 보기도 한다. 근데 대부분 람다로 대체 가능하다. mem_fn을 통해 p->f(a)호출규약을 f(p,a)로 바꿀 수 있다.
9.	function은 bind()의 결과를 특정 타입을 가진 변수에 대입하고 싶을 때 사용된다. function은 callable을 보관하는 타입이며 이 객체는 functor이다.

	[메모리와 자원]
1.	일반적인 배열과 std::array의 차이점은 포인터로의 암시적인 변화늘 막아준다는 것이다.
2.	bitset을 이용하거나 일반 set, enum, bitfield, vector<bool>등을 이용하여 비트정보표현이 가능하나, bitset<N>은 N비트를 가진 배열로 고정된 크기를 가지며 정수에 의해 색인되며 비트를 조작하는 연산(set(),reset(),bs2=~bs ..etc)을 제공한다.(다만 기본제공포인터로 단일비트 직접 주소지정은 불가능. 오로지 참조자(프락시)로만)
	유의할 점은 논리시프트만 되며, size_t를 사용하기에 음수 shift는 불가능하다. to_ullong()이나 to_string을 통하여 타 타입으로 변환이 가능하다. 다만 출력을 위한 string변환이라면 그냥 bitset출력 연산자를 직접적으로 이용하면 8비트크기를 가정하기에 좀 더 읽기 편하다.(p.s bitset이 이용하는 array는 낮은index가 높은 주소를 갖는 반면, vector<bool>은 높은 주소가 높은 index를 갖는다)
3.	pair사용 시 first와 second를 다른 tuple에서 갖고오고 싶다면 pair<T,U> p{piecewise_construct, t, t2}을 사용하는데, piecewise_construct는 piecewise_construct_t타입객체의 이름으로 tuple멤버를 가진 pair생성과 first와 second에 대한 인자리스트로 tuple을 사용하여 pair생성을 구분하기 위해 사용한다.
4.	tuple은 explicit생성자를 이용하여 사용할 수 있는데, tie(args)_좌변, forward_as_tuple(args)_우변등 여러 tuple<Types...>보조 함수들이 존재한다.
5.	shared_ptr은 객체를 가리키는 포인터, 사용카운트&삭제자를 가리키는 포인터 총 2개의 포인터를 가진 구조이다. 다만 shared_ptr의 순환 링크구조는 메모리를 누출시킬 수 있으며, 멀티스레딩 환경에서는 데이터경합방지를 위해 많은 비용이 들 수 있으며, 소멸자가 호출되는 시점이 예측되지 않으며, 대규모 데이터 보관시 연쇄적인 소멸자 덕에 GC delay가 발생할 수 있다.(순환구조에선 weak_ptr사용하자)
6.	weak_ptr은 shared_ptr이 관리하는 객체를 가리키며, lock()을 이용하여 shared_ptr로 변환이 가능하다. 이는 존재할 경우에만 접근해야하는 객체, 언제라도 삭제될 수 있는 객체, 사용 후 반드시 소멸자가 호출되어야하는 객체에 사용한다. 객체에 대한 마지막 shared_ptr소멸 뒤 weak_ptr잔여여부를 알기 위해 weak use count를 사용한다. use count를 올리지 않는 shared_ptr의 reference느낌이다.
7.	메모리를 반환하고 해제하는 방식으로 직접 할당자를 만들 수 있고, 할당하는 객체가 실제로 상태를 가진경우에만 컨테이너 공간 오버헤드를 유발하는데 이는 비어있는 기반 클래스 최적화(EBCO_빈 클래스는 주소할당을위한 1의 공간오버헤드를 갖는데 C++에서 상속시 기반클래스가 비어있다면 총 공간이 2가 아닌 1이 되게 최적화해줌)를 이용해 달성한다.
	allocator는 포인터의 속성과 프락시 타입을 판별하기 위해 pointer_traits를 사용한다. 이는 allocator_traits와 유사하게 꼼수를 통해 default value를 이용한다.
8.	Your_allocator를 사용하는 Your_string과 My_allocator을 사용하는 My_vector를 이용하여 My_vector<Your_string>같이 종합된 버전을 만들때 유효범위를 가진 할당자를 이용한다. 즉 원소에게 어떤 할당자를 전달할지 알려주는 기능을 컨테이너에 넣는 것으로, 외부의 할당자와 내부의 할당자를 추적 관리하는 메커니즘을 제공하는 scoped_allocator_adpator클래스등을 이용한다.
	대부분 default allocator를 사용하지만 메모리와 관련된 심각한 성능상의 제약조건이 있다면 부분적으로 다른 customized allocator를 사용하는 것이 중요할 수 있다.
9.	Garbage Collection Interface에 앞서 적합한 의미 구조를 가진 자원 핸들을 사용한 후에 최후수단으로 사용하는 것이 좋다. GC는 비메모리 자원을 다룰 순 없지만 메모리의 재확보/재사용을 가능케 하며 누출 시칸을 상당히 늘릴 수 있고, 누출의 원인을 찾는 도구로도 사용된다. 다만 이는 명시적으로 설치되고 활성화되지 않으면 실행되지 않는다.
	GC를 제어하는데에 C++에서 safely-derived pointer(non disguised pointer_포인터를 숨기거나, XOR 수법으로 압축하거나...)의 관점에서 Application Binary Interface(ABI)를 제공하는데, disguised pointer 즉 위장 포인터는 비트 패턴이 잘못된 타입으로 메모리에 저장돼있더라도 정렬만 제대로 돼있으면 GC에 의해 발견될 수있는데, 이것을 traceable이라 부른다.
	표준라이브러리는 컬렉터가 해당 메모리를 가리키는 포인터를 발견하지 못할때에도 회수되지 말아야 할 메모리와 포인터가 발견되지 말아야 할 위치를 프로그래머가 지정할 수 있게해준다.(ABI) C++ GC는 conservative collector로 declare_no_pointers()로 메모리의 상당 부분을 안전하게 GC고려 대상에서 제외하므로써 효율성을 높여준다.
10.	GC 열거자는 다음과 같다. relaxed_안전하게 파생된 포인터나 그것을 가리키는 traceable 포인터가 아닌 모든 객체를 수집, preferred_relaxed와 비슷하지만 누출탐지기나 부적절한 포인터의 역참조탐지기로 실행, strict_안전하게 파생되지 않은 포인터들을 무시.
11.	<memory>에서 allocator외에도 미초기화 메모리를 다루기위해 fill*계열 함수를 제공하는데, 초기화,소멸시키지 않는 임시버퍼의 할당과 할당해제에 사용된다. 즉 이들은 저수준이기에 new나 allocator::allocate()의 대안으로 사용하지 않는다.
	임시버퍼외에도 시퀸스멤버가 초기화돼있다고 가정하는 표준 알고리즘의 즉시적인 대상으로 미초기화 메모리를 사용할 수 없기에 대입대신 초기화를 하는 <memory>의 raw_storage_buffer을 사용할 수 있다. 이 경우들을 제외하곤 사용하지 않는다..
	
	[유틸리티]
1.	