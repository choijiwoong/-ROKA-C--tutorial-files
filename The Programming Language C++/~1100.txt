	[STL 알고리즘]
1.	반복자 기반의 인터페이스는 시퀸스 개념은ㄹ 직접적으로 표현하지 않아 일부 범위 오류를 탐지 하는데 어려움을 겪을 가능성이 있다. 또한 표준 라이브러리 알고리즘은 설계시 STL의 이동의미구조에 대한 지원이 없었기에 반복자를 반환하는데, 이는 새 container를 반환하여 해결이 가능하다(by ex. vactor<Value_type<Cont>*>)
2.	지정되지 않는 한 알고리즘에 전달되는 정책인자(Predicate)는 원소를 변경하지 않아야 하며 사용이 필요하다면 const를 붙여 보호해야한다(or for_each이용.). 또한 predicate는 연산의 의미를 변경하는 상태를 보유하지 않아야 한다.(포인터 원소에 대한 ==와 <은 STL에 거의모두 옮지 않다)
3.	sequence predicate로는 all_of(b,e,f), any_of(b,e,f), none_of(b,e,f)가 있는데 실패 시 어느 원소가 실패했는지는 알 수 없다. count(b,e,v)도 predicate를 이용하는 count_if(b,e,f)로 사용이 가능하다.
	equal(), mismatch(), search(), search_n(), transform()_입력 항상 바꾸진 않음, copy()_back_inserter(v)처럼 삽입자 사용 가능, copy_if(), move_backward(), unique()_중복원소없이 이동 but 컨테이너 종류 모르기에 우리가 기대하는 방식이 아닐 수도 있기에 명시적으로 erase사용하는 컨테이너로 변경해야함, unique_copy(),
	remove()_몇몇 algorithm들은 input sequence의 size변경이 불가하기에 크기가 변경 안될 수도 있음+원소를 뒤끝으로 이동시켜 제거, reverse(), replace(), rotate()_by using swap, random_shuffle()_by using uniform distribution random generator, partition(), partition_point(), is_partitioned(),
	next_permutation(), is_permutation()_sort on dictionary, fill(), generate()_fill이랑 유사한데 f를 하나 더 받아 f()반환값을 assign함, iter_swap _iterator가 가리키는 원소를 swap, stable_sort(), is_sorted_until(), nth_element(b,n,e)_n은 정렬해도 현재위치
4.	표준 list는 Random Access Iterator가 없기에 필요시 vector로 복사해서 다시 list로 옮겨야 한다. 또한 STL 알고리즘은 ==가 아니라 동등성 비교인 !(a<b)&&!(a>b)  == !((a<b)||(a>b))을 사용한다는 것을 유의하자.
5.	binary_search(), equal_range(), lower_bound(), upper_bound()와 같은 이진검색계열 알고리즘은 bidirectional iterator없이 forward-iterator만으로 구현이 가능하다.
6.	merge()_out따로 존재, inplace_merge()_레알 병합, 집합알고리즘: includes(), set_union(), set_intersection(), set_difference(), set_symmetric_difference()
7.	Heap은 가장 높은 값을 맨 앞에 놓는 간결한 데이터 구조이다. make_heap(), push_heap(), pop_heap(), sort_heap(), is_heap(), is_heap_until()
8.	lexicographical_compare()는 사전에서 순서를 정렬할 때 쓰이는 규칙, min과 max계열: pair(x,y)=minmax(a,b)

	[STL 반복자]
1.	반복자의 카테고리로는 input iterator, output iterator, forward iterator, bidirectional iterator, random-access iterator로 크게 5가지가 있다. 이들은 클래스가 아닌 concept이므로 class hierarchy가 아니다.
2.	<iterator>의 반복자 특성 정보 iterator_traits<>, input_iterator_tag, output_iterator_tag, forward_iterator_tag, bidirectional_iterator_tag, random_access_iterator_tag를 사용할 수 있다. 이들을 사용하는 코드들은 tag dispatch기법으로 inline화 될 것이다.
	반복자를 인자로 받는 코드에 typename iterator_traits<Iter>::value_type 혹은 ::reference_type처럼 iterator_traits를 사용하여 구현하며 pointer 입력 시에도 정상적으로 거를 수 있다. 
	이를 이용하여 두 반복자 사이의 차이에 대한 타입을 알고 싶을 때 (실제로는 별칭사용) typename std::iteator_traits<Iter>::difference_type<Iter> d4=distance(p,q) 혹은 auto d5=distance(p,q)를 사용하면 된다.
3.	유용한 반복자 타입을 생성할 수 있는 iterator adaptor로는 reverse_iterator, back_insert_iterator, front_insert_iterator, insert_iterator, move_iterator, raw_storage_iterator가 있다.
4.	삽입 반복자로는 insert_iterator, front_isert_iterator, back_insert_iterator가 있으며 각각 insert(), push_front(), push_back()을 사용하여 삽입한다. 이들은 다음과 같은 삽입자 생성 함수를 통해 생성된다. inserter(), back_inserter(), front_inserter() 이들은 컨테이너의 반복자여야 한다.
5.	이동 삽입자(복사가 아닌 이동)은 이동 반복자 생성 함수 make_move_iterator을 이용하여 만들어진다. ex. copy(make_move_iterator(vs2.begin()), make_move_iterator(vs.end()), back_inserter(vs3));
6.	<iterator> 표준 라이브러리에서 웬만한 것들은 다 받을 수 있는 begin()과 end()를 제공한다. 이들은 자동적으로 begin()과 end()를 가진 사용자 정의 컨테이너에 획득되기에 직접 커스텀 한 멤버 버전을 사용하고싶으면 template<typename T> Iterator<My_container<T>> begin(My_container<T>& c) { return Iterator<My_container<T>>{&c[0]; }; }과 같이 오버로딩해야한다.
7.	<functional>에서 주로 사용되는 predicate들을 제공한다. 산술연산도 마찬가지이다. functional adaptor는 함수인자를 받아들이고 원래 함수를 실행시키는 함수 객체를 반환한다. bind(f, args), mem_fn(f), not1(f), not2(f)등이 있다. bind와 mem_fn은 Currying이나 partial evaluation라고 불리는 argument binding을 수행한다.
8.	